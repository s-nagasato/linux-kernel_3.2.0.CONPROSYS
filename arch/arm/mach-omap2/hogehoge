2c2
<  * Code for AM335X EVM.
---
>  * Code for MC341.
14a15,42
> // update 2015.02.03 XDMA_EVENT_INTRO config update
> // update 2015.02.04 LAN_INTn, RTC_INTn init set (DBG-SW add)
> // update 2015.02.04 UART3, SPI1 init
> // update 2015.02.05 uart3 update
> // update 2015.02.06 2LAN setup
> // update 2015.02.09 spidev test
> // 2015.2.11 add usb
> // update 2015.02.12 max_speed 6Mbps
> // update 2015.02.18 am33xx_cpsw_init
> // update 2015.02.18 SPI2.0 // .mode = SPI_MODE_2,
> // update 2015.02.25 usb on
> // update 2015.02.26 uart5 update
> // update 2015.03.02 3G power
> // update 2015.03.03 LED update
> // update 2015.03.05 gpio1_7
> // update 2015.03.05 CM_CLOCKOUT_CTRL
> // update 2015.03.05 RTC mcp7940
> // update 2015.03.09 nmi set
> // update 2015.03.16 RFID add
> 
> 
> #define MC341LAN2 (1)
> #define MC341
> #ifndef MC341
> /*
> */
> #endif
> 
50c78,79
< #include <mach/board-am335xevm.h>
---
> // #include <mach/board-am335xevm.h>
> #include <mach/board-mc341.h>
71a101
> #include "cm33xx.h"
87a118,176
> // add 2014.11.25
> /* TLK PHY IDs */
> // #define TLK110_PHY_ID 0x2000A201
> // TLK105 0x2000a211
> #define TLK110_PHY_ID   0x2000A201
> #define TLK105_PHY_ID   0x2000A211
> #define TLK110_PHY_MASK 0xfffffff0
> 
> /* TLK110 PHY register offsets */
> #define TLK110_COARSEGAIN_REG 0x00A3
> #define TLK110_LPFHPF_REG 0x00AC
> #define TLK110_SPAREANALOG_REG 0x00B9
> #define TLK110_VRCR_REG 0x00D0
> #define TLK110_SETFFE_REG 0x0107
> #define TLK110_FTSP_REG 0x0154
> #define TLK110_ALFATPIDL_REG 0x002A
> #define TLK110_PSCOEF21_REG 0x0096
> #define TLK110_PSCOEF3_REG 0x0097
> #define TLK110_ALFAFACTOR1_REG 0x002C
> #define TLK110_ALFAFACTOR2_REG 0x0023
> #define TLK110_CFGPS_REG 0x0095
> #define TLK110_FTSPTXGAIN_REG 0x0150
> #define TLK110_SWSCR3_REG 0x000B
> #define TLK110_SCFALLBACK_REG 0x0040
> #define TLK110_PHYRCR_REG 0x001F
> 
> /* TLK110 register writes values */
> #define TLK110_COARSEGAIN_VAL 0x0000
> #define TLK110_LPFHPF_VAL 0x8000
> #define TLK110_SPANALOG_VAL 0x0000
> #define TLK110_VRCR_VAL 0x0008
> #define TLK110_SETFFE_VAL 0x0605
> #define TLK110_FTSP_VAL 0x0255
> #define TLK110_ALFATPIDL_VAL 0x7998
> #define TLK110_PSCOEF21_VAL 0x3A20
> #define TLK110_PSCOEF3_VAL 0x003F
> #define TLK110_ALFACTOR1_VAL 0xFF80
> #define TLK110_ALFACTOR2_VAL 0x021C
> #define TLK110_CFGPS_VAL 0x0000
> #define TLK110_FTSPTXGAIN_VAL 0x6A88
> #define TLK110_SWSCR3_VAL 0x0000
> #define TLK110_SCFALLBACK_VAL 0xC11D
> #define TLK110_PHYRCR_VAL 0x4000
> 
> #ifdef CONFIG_TLK110_WORKAROUND
> #define mc341_tlk110_phy_init()\
>  phy_register_fixup_for_uid(TLK105_PHY_ID, TLK110_PHY_MASK, mc341_tlk110_phy_fixup);
> /*
>  do { \
>  phy_register_fixup_for_uid(TLK105_PHY_ID,\
>  TLK110_PHY_MASK,\
>  mc341_tlk110_phy_fixup);\
>  } while (0);
> */
> #else
> #define mc341_tlk110_phy_init() do { } while (0);
> #endif
> 
> 
94c183
< /* bit 3: 0 - enable, 1 - disable for pull enable */
---
> // bit 3: 0 - enable, 1 - disable for pull enable
107,137d195
< 
< static const struct display_panel bone_lcd_cape_disp_panel = {
< 	WVGA,
< 	16,
< 	16,
< 	COLOR_ACTIVE,
< };
< 
< /* LCD backlight platform Data */
< #define AM335X_BACKLIGHT_MAX_BRIGHTNESS        100
< #define AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS    100
< #define AM335X_PWM_PERIOD_NANO_SECONDS        (5000 * 10)
< 
< static struct platform_pwm_backlight_data am335x_backlight_data0 = {
< 	.pwm_id         = "ecap.0",
< 	.ch             = -1,
< 	.lth_brightness	= 21,
< 	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
< 	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
< 	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
< };
< 
< static struct platform_pwm_backlight_data am335x_backlight_data2 = {
< 	.pwm_id         = "ecap.2",
< 	.ch             = -1,
< 	.lth_brightness	= 21,
< 	.max_brightness = AM335X_BACKLIGHT_MAX_BRIGHTNESS,
< 	.dft_brightness = AM335X_BACKLIGHT_DEFAULT_BRIGHTNESS,
< 	.pwm_period_ns  = AM335X_PWM_PERIOD_NANO_SECONDS,
< };
< 
154,202d211
< 
< static struct lcd_ctrl_config bone_lcd_cape_cfg = {
< 	&bone_lcd_cape_disp_panel,
< 	.ac_bias                = 255,
< 	.ac_bias_intrpt         = 0,
< 	.dma_burst_sz           = 16,
< 	.bpp                    = 16,
< 	.fdd                    = 0x80,
< 	.tft_alt_mode           = 0,
< 	.stn_565_mode           = 0,
< 	.mono_8bit_mode         = 0,
< 	.invert_line_clock      = 1,
< 	.invert_frm_clock       = 1,
< 	.sync_edge              = 0,
< 	.sync_ctrl              = 1,
< 	.raster_order           = 0,
< };
< 
< struct da8xx_lcdc_platform_data TFC_S9700RTWV35TR_01B_pdata = {
< 	.manu_name		= "ThreeFive",
< 	.controller_data	= &lcd_cfg,
< 	.type			= "TFC_S9700RTWV35TR_01B",
< };
< 
< void cape_panel_power_ctrl (int state)
< {
< 	if (state)
< 	{
< 		gpio_direction_output(BEAGLEBONE_LCD_BL, 1);
< 	}
< 	else
< 	{
< 		gpio_direction_output(BEAGLEBONE_LCD_BL, 0);
< 	}
< }
< 
< struct da8xx_lcdc_platform_data TFC_S9700RTWV35TR_01B_bone_lcd_cape_pdata = {
< 	.manu_name		= "ThreeFive",
< 	.controller_data	= &bone_lcd_cape_cfg,
< 	.type			= "TFC_S9700RTWV35TR_01B",
< 	.panel_power_ctrl	= cape_panel_power_ctrl,
< };
< 
< struct da8xx_lcdc_platform_data Sharp_LCD035Q3DG01_pdata = {
< 	.manu_name		= "Sharp",
< 	.controller_data	= &lcd_cfg,
< 	.type			= "Sharp_LCD035Q3DG01",
< };
< 
211,290c220
< #include <linux/lis3lv02d.h>
< 
< static const struct display_panel dvi_panel = {
< 	WVGA,
< 	16,
< 	16,
< 	COLOR_ACTIVE,
< };
< 
< static struct lcd_ctrl_config dvi_cfg = {
< 	&dvi_panel,
< 	.ac_bias    = 255,
< 	.ac_bias_intrpt    = 0,
< 	.dma_burst_sz    = 16,
< 	.bpp      = 16,
< 	.fdd      = 0x80,
< 	.tft_alt_mode    = 0,
< 	.stn_565_mode    = 0,
< 	.mono_8bit_mode    = 0,
< 	.invert_line_clock  = 1,
< 	.invert_frm_clock  = 1,
< 	.sync_edge    = 0,
< 	.sync_ctrl    = 1,
< 	.raster_order    = 0,
< };
< 
< struct da8xx_lcdc_platform_data dvi_pdata = {
< 	.manu_name    = "BBToys",
< 	.controller_data  = &dvi_cfg,
< 	.type      = "1024x768@60",
< };
< 
< /* TSc controller */
< static struct tsc_data am335x_touchscreen_data  = {
< 	.wires  = 4,
< 	.x_max = 0x0fff,
< 	.y_max = 0x0fff,
< 	.x_plate_resistance = 200,
< };
< 
< static u8 am335x_iis_serializer_direction1[] = {
< 	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	RX_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< };
< 
< static struct snd_platform_data am335x_evm_snd_data1 = {
< 	.tx_dma_offset	= 0x46400000,	/* McASP1 */
< 	.rx_dma_offset	= 0x46400000,
< 	.op_mode	= DAVINCI_MCASP_IIS_MODE,
< 	.num_serializer	= ARRAY_SIZE(am335x_iis_serializer_direction1),
< 	.tdm_slots	= 2,
< 	.serial_dir	= am335x_iis_serializer_direction1,
< 	.asp_chan_q	= EVENTQ_2,
< 	.version	= MCASP_VERSION_3,
< 	.txnumevt	= 1,
< 	.rxnumevt	= 1,
< };
< 
< static u8 am335x_evm_sk_iis_serializer_direction1[] = {
< 	INACTIVE_MODE,	INACTIVE_MODE,	TX_MODE,	INACTIVE_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< 	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
< };
< 
< static struct snd_platform_data am335x_evm_sk_snd_data1 = {
< 	.tx_dma_offset	= 0x46400000,	/* McASP1 */
< 	/*.rx_dma_offset	= 0x46400000,*/
< 	.op_mode	= DAVINCI_MCASP_IIS_MODE,
< 	.num_serializer	= ARRAY_SIZE(am335x_evm_sk_iis_serializer_direction1),
< 	.tdm_slots	= 2,
< 	.serial_dir	= am335x_evm_sk_iis_serializer_direction1,
< 	.asp_chan_q	= EVENTQ_2,
< 	.version	= MCASP_VERSION_3,
< 	.txnumevt	= 1,
< };
< 
< static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
---
> static struct omap2_hsmmc_info mc341_mmc[] __initdata = {
319c249,254
< 	AM33XX_MUX(XDMA_EVENT_INTR0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT),
---
> 	// update 2015.02.03 XDMA_EVENT_INTRO config update
> 	// AM33XX_MUX(XDMA_EVENT_INTR0, OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT),
> 	
> //	AM33XX_MUX(XDMA_EVENT_INTR0, OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP), // MC341LAN1
> //	{"xdma_event_intr0.spi1_cs1", OMAP_MUX_MODE4 | AM33XX_PIN_OUTPUT},		/* SPI1_CS1 */ // MC341LAN2
> 	AM33XX_MUX(XDMA_EVENT_INTR0, OMAP_MUX_MODE4 | AM33XX_PIN_OUTPUT), // MC341LAN2 
323a259,264
> // for i2c1
> 	AM33XX_MUX(UART0_CTSN, OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
> 			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
> 	AM33XX_MUX(UART0_RTSN, OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
> 			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
> 
357c298
< static u32 am335x_evm_id;
---
> // static u32 am335x_evm_id;
387a329,330
> /*
> */
395d337
< 
424c366
< 
---
> /*
433,462d374
< 
< /*
< *LCD cape EEPROM config
< *
< *-------------------------------------------------------------------
< *Name		offset	size 	contents
< *--------------------------------------------------------------------
< 
< *Header 	0 	4 	0xAA, 0x55, 0x33, 0xEE
< *EEPROM Format
< *
< *Revision	4 	2 	Revision number of the overall format
< *				of this EEPROM in ASCII =A0
< *
< *Board Name 	6 	32 	Name of board in ASCII
< *
< *Version 	38 	4 	Hardware version code for board in ASCII
< *
< *Manufacturer 	42 	16 	ASCII name of the manufacturer
< *
< *Part Number 	60 	16 	ASCII Characters for the part number
< *
< *Number of Pins 74 	2 	Number of pins used by the daughter board
< *
< *Serial Number	76	12	Serial number of the board. This is a 12
< *				character string which is:
< *				WWYY4P13nnnn where:
< *				WW = 2 digit week of the year of production
< *				YY = 2 digit year of production
< *				nnnn = incrementing board number
465,475d376
< struct lcd_cape_eeprom_config {
< 	u8	header[4];
< 	u8 	revision[2];
< 	u8	board_name[32];
< 	u8	version[4];
< 	u8	manufacturer[16];
< 	u8	part_no[16];
< 	u8 	no_of_pins[2];
< 	u8 	serial_no[12];
< };
< 
477,478c378,393
< static struct am335x_eeprom_config1 config1;
< static struct lcd_cape_eeprom_config cape_eeprom_config;
---
> // static struct am335x_eeprom_config1 config1;
> 
> struct mc341_eeprom_config {
> 	u32	header;		// 0xee3355aa
> 	u8	name[8];	// AM335X03
> 	u8	clock_mem;	// 0x11 = (0x10 600) + (0x01 128)
> 					// CPU:0x80 1000, 0x40 800, 0x10 600
> 					// MEM:0x02 512, 0x00 256, 0x01 128
> 	u8	display;	//  0x00FCMOS OUT DISABLEALVDS OUT DISABLE
> 	u8	mac0[6];	// mac address
> 	u8	mac1[6];	// mac address
> 	u8	ssp;		// Select Spread Spectrum Clocking 0x00FNone
> 	u8	debport;	// 
> 	u8	serial[14];	// x(7)9(6)+0x0
> };
> static struct mc341_eeprom_config config_mc341;
482,483c397,400
< #define EEPROM_MAC_ADDRESS_OFFSET	60 /* 4+8+4+12+32 */
< #define EEPROM_NO_OF_MAC_ADDR		3
---
> // #define EEPROM_MAC_ADDRESS_OFFSET	60 /* 4+8+4+12+32 */
> #define EEPROM_MAC_ADDRESS_OFFSET	14 /* 4+8+1+1 */
> // #define EEPROM_NO_OF_MAC_ADDR		3
> #define EEPROM_NO_OF_MAC_ADDR		2
491c408
< * am335x_evm_set_id - set up board evmid
---
> * mc341_set_id - set up board evmid
496c413
< void am335x_evm_set_id(unsigned int evmid)
---
> void mc341_set_id(unsigned int evmid)
503c420
< * am335x_evm_get_id - returns Board Type (EVM/BB/EVM-SK ...)
---
> * mc341_get_id - returns Board Type (EVM/BB/EVM-SK ...)
508c425
< int am335x_evm_get_id(void)
---
> int mc341_get_id(void)
512,542c429
< EXPORT_SYMBOL(am335x_evm_get_id);
< 
< /* current profile if exists else PROFILE_0 on error */
< static u32 am335x_get_profile_selection(void)
< {
< 	int val = 0;
< 
< 	if (!cpld_client)
< 		/* error checking is not done in func's calling this routine.
< 		so return profile 0 on error */
< 		return 0;
< 
< 	val = i2c_smbus_read_word_data(cpld_client, CPLD_CFG_REG);
< 	if (val < 0)
< 		return 0;	/* default to Profile 0 on Error */
< 	else
< 		return val & 0x7;
< }
< 
< static struct pinmux_config haptics_pin_mux[] = {
< 	{"gpmc_ad9.ehrpwm2B",		OMAP_MUX_MODE4 |
< 		AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for LCD Cape. LCDC pinmux already being set */
< static struct pinmux_config lcd_cape_pin_mux[] = {
< 	{"gpmc_a2.gpio1_18", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
---
> EXPORT_SYMBOL(mc341_get_id);
544c431
< /* Module pin mux for LCDC */
---
> // Module pin mux for LCDC
546,751d432
< 	{"lcd_data0.lcd_data0",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data1.lcd_data1",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data2.lcd_data2",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data3.lcd_data3",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data4.lcd_data4",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data5.lcd_data5",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data6.lcd_data6",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data7.lcd_data7",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data8.lcd_data8",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data9.lcd_data9",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data10.lcd_data10",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data11.lcd_data11",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data12.lcd_data12",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data13.lcd_data13",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data14.lcd_data14",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"lcd_data15.lcd_data15",	OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 						       | AM33XX_PULL_DISA},
< 	{"gpmc_ad8.lcd_data16",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad9.lcd_data17",		OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad10.lcd_data18",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad11.lcd_data19",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad12.lcd_data20",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad13.lcd_data21",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad14.lcd_data22",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_ad15.lcd_data23",	OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},
< 	{"lcd_vsync.lcd_vsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_hsync.lcd_hsync",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_pclk.lcd_pclk",		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for DVI board */
< static struct pinmux_config dvi_pin_mux[] = {
< 	{"lcd_data0.lcd_data0",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data1.lcd_data1",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data2.lcd_data2",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data3.lcd_data3",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data4.lcd_data4",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data5.lcd_data5",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data6.lcd_data6",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data7.lcd_data7",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data8.lcd_data8",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data9.lcd_data9",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data10.lcd_data10",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data11.lcd_data11",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data12.lcd_data12",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data13.lcd_data13",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data14.lcd_data14",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_data15.lcd_data15",  OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT
< 		| AM33XX_PULL_DISA},
< 	{"lcd_vsync.lcd_vsync",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_hsync.lcd_hsync",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_pclk.lcd_pclk",      OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"lcd_ac_bias_en.lcd_ac_bias_en", OMAP_MUX_MODE0
< 		| AM33XX_PIN_OUTPUT}, /*DVIEN*/
< 	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE7
< 		| AM33XX_PIN_OUTPUT}, /* USR0 LED*/
< 	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE7
< 		| AM33XX_PIN_OUTPUT}, /* USR1 LED*/
< 	{"gpmc_ad7.gpmc_ad7", OMAP_MUX_MODE7
< 		| AM33XX_PIN_OUTPUT}, /* DVI PDn */
< 	{NULL, 0},
< };
< 
< static struct pinmux_config tsc_pin_mux[] = {
< 	{"ain0.ain0",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{"ain1.ain1",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{"ain2.ain2",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{"ain3.ain3",           OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{"vrefp.vrefp",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{"vrefn.vrefn",         OMAP_MUX_MODE0 | AM33XX_INPUT_EN},
< 	{NULL, 0},
< };
< 
< /* Pin mux for nand flash module */
< static struct pinmux_config nand_pin_mux[] = {
< 	{"gpmc_ad0.gpmc_ad0",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad1.gpmc_ad1",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad2.gpmc_ad2",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad3.gpmc_ad3",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad4.gpmc_ad4",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad5.gpmc_ad5",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad6.gpmc_ad6",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad7.gpmc_ad7",	  OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_wait0.gpmc_wait0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_wpn.gpmc_wpn",	  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_csn0.gpmc_csn0",	  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
< 	{"gpmc_advn_ale.gpmc_advn_ale",  OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
< 	{"gpmc_oen_ren.gpmc_oen_ren",	 OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
< 	{"gpmc_wen.gpmc_wen",     OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
< 	{"gpmc_ben0_cle.gpmc_ben0_cle",	 OMAP_MUX_MODE0 | AM33XX_PULL_DISA},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for SPI fash */
< static struct pinmux_config spi0_pin_mux[] = {
< 	{"spi0_sclk.spi0_sclk", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
< 							| AM33XX_INPUT_EN},
< 	{"spi0_d0.spi0_d0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
< 							| AM33XX_INPUT_EN},
< 	{"spi0_d1.spi0_d1", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL
< 							| AM33XX_INPUT_EN},
< 	{"spi0_cs0.spi0_cs0", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL | AM33XX_PULL_UP
< 							| AM33XX_INPUT_EN},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for SPI flash */
< static struct pinmux_config spi1_pin_mux[] = {
< 	{"mcasp0_aclkx.spi1_sclk", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
< 		| AM33XX_INPUT_EN},
< 	{"mcasp0_fsx.spi1_d0", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
< 		| AM33XX_PULL_UP | AM33XX_INPUT_EN},
< 	{"mcasp0_axr0.spi1_d1", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
< 		| AM33XX_INPUT_EN},
< 	{"mcasp0_ahclkr.spi1_cs0", OMAP_MUX_MODE3 | AM33XX_PULL_ENBL
< 		| AM33XX_PULL_UP | AM33XX_INPUT_EN},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for rgmii1 */
< static struct pinmux_config rgmii1_pin_mux[] = {
< 	{"mii1_txen.rgmii1_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_rxdv.rgmii1_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_txd3.rgmii1_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd2.rgmii1_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd1.rgmii1_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd0.rgmii1_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txclk.rgmii1_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"mii1_rxclk.rgmii1_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd3.rgmii1_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd2.rgmii1_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd1.rgmii1_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd0.rgmii1_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for rgmii2 */
< static struct pinmux_config rgmii2_pin_mux[] = {
< 	{"gpmc_a0.rgmii2_tctl", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a1.rgmii2_rctl", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"gpmc_a2.rgmii2_td3", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a3.rgmii2_td2", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a4.rgmii2_td1", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a5.rgmii2_td0", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a6.rgmii2_tclk", OMAP_MUX_MODE2 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a7.rgmii2_rclk", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"gpmc_a8.rgmii2_rd3", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"gpmc_a9.rgmii2_rd2", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"gpmc_a10.rgmii2_rd1", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"gpmc_a11.rgmii2_rd0", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for mii1 */
< static struct pinmux_config mii1_pin_mux[] = {
< 	{"mii1_rxerr.mii1_rxerr", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_txen.mii1_txen", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"mii1_rxdv.mii1_rxdv", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_txd3.mii1_txd3", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd2.mii1_txd2", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd1.mii1_txd1", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txd0.mii1_txd0", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"mii1_txclk.mii1_txclk", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxclk.mii1_rxclk", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd3.mii1_rxd3", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd2.mii1_rxd2", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd1.mii1_rxd1", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxd0.mii1_rxd0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mdio_data.mdio_data", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"mdio_clk.mdio_clk", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT_PULLUP},
769,792c450,460
< 
< static struct pinmux_config i2c1_pin_mux[] = {
< 	{"spi0_d1.i2c1_sda",    OMAP_MUX_MODE2 | AM33XX_SLEWCTRL_SLOW |
< 					AM33XX_PULL_ENBL | AM33XX_INPUT_EN},
< 	{"spi0_cs0.i2c1_scl",   OMAP_MUX_MODE2 | AM33XX_SLEWCTRL_SLOW |
< 					AM33XX_PULL_ENBL | AM33XX_INPUT_EN},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config i2c2_pin_mux[] = {
< 	{"uart1_ctsn.i2c2_sda",    OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
< 					AM33XX_PULL_UP | AM33XX_INPUT_EN},
< 	{"uart1_rtsn.i2c2_scl",   OMAP_MUX_MODE3 | AM33XX_SLEWCTRL_SLOW |
< 					AM33XX_PULL_UP | AM33XX_INPUT_EN},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for mcasp1 */
< static struct pinmux_config mcasp1_pin_mux[] = {
< 	{"mii1_crs.mcasp1_aclkx", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_rxerr.mcasp1_fsx", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"mii1_col.mcasp1_axr2", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
< 	{"rmii1_refclk.mcasp1_axr3", OMAP_MUX_MODE4 |
< 						AM33XX_PIN_INPUT_PULLDOWN},
---
> //MC341LAN2
> /* Module pin mux for rmii2 */
> static struct pinmux_config rmii2_pin_mux[] = {
> 	{"gpmc_wait0.rmii2_crs_dv", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
> 	{"gpmc_wpn.rmii2_rxerr", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
> 	{"gpmc_a0.rmii2_txen", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
> 	{"gpmc_a4.rmii2_txd1", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
> 	{"gpmc_a5.rmii2_txd0", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
> 	{"gpmc_a10.rmii2_rxd1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
> 	{"gpmc_a11.rmii2_rxd0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLDOWN},
> 	{"mii1_col.rmii2_refclk", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLDOWN},
808,811c476,479
< static struct pinmux_config mmc0_wp_only_pin_mux[] = {
< 	{"mcasp0_aclkr.gpio3_18", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
---
> // static struct pinmux_config mmc0_wp_only_pin_mux[] = {
> //	{"ecap0_in_pwm0_out.mmc0_sdwp", OMAP_MUX_MODE5 | AM33XX_PIN_INPUT_PULLUP},
> //	{NULL, 0},
> // };
814,872c482
< 	{"spi0_cs1.gpio0_6",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for mmc1 */
< static struct pinmux_config mmc1_common_pin_mux[] = {
< 	{"gpmc_ad3.mmc1_dat3",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad2.mmc1_dat2",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad1.mmc1_dat1",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad0.mmc1_dat0",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_csn1.mmc1_clk",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_csn2.mmc1_cmd",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config mmc1_dat4_7_pin_mux[] = {
< 	{"gpmc_ad7.mmc1_dat7",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad6.mmc1_dat6",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad5.mmc1_dat5",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ad4.mmc1_dat4",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config mmc1_wp_only_pin_mux[] = {
< 	{"gpmc_csn0.gpio1_29",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config mmc1_cd_only_pin_mux[] = {
< 	{"gpmc_advn_ale.gpio2_2", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for uart3 */
< static struct pinmux_config uart3_pin_mux[] = {
< 	{"spi0_cs1.uart3_rxd", AM33XX_PIN_INPUT_PULLUP},
< 	{"ecap0_in_pwm0_out.uart3_txd", AM33XX_PULL_ENBL},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config d_can_gp_pin_mux[] = {
< 	{"uart0_ctsn.d_can1_tx", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
< 	{"uart0_rtsn.d_can1_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config d_can_ia_pin_mux[] = {
< 	{"uart0_rxd.d_can0_tx", OMAP_MUX_MODE2 | AM33XX_PULL_ENBL},
< 	{"uart0_txd.d_can0_rx", OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for uart2 */
< static struct pinmux_config uart2_pin_mux[] = {
< 	{"spi0_sclk.uart2_rxd", OMAP_MUX_MODE1 | AM33XX_SLEWCTRL_SLOW |
< 						AM33XX_PIN_INPUT_PULLUP},
< 	{"spi0_d0.uart2_txd", OMAP_MUX_MODE1 | AM33XX_PULL_UP |
< 						AM33XX_PULL_DISA |
< 						AM33XX_SLEWCTRL_SLOW},
---
> 	{"spi0_cs1.mmc0_sdcd",  OMAP_MUX_MODE5 | AM33XX_PIN_INPUT_PULLUP},
875,876c485
< 
< /* pinmux for gpio based key */
---
> // pinmux for gpio based key
878,881c487,491
< 	{"gpmc_wait0.gpio0_30", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_oen_ren.gpio2_3", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_advn_ale.gpio2_2", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_ben0_cle.gpio2_5", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
---
> 	{"gpmc_ad0.gpio1_0", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},			/* DBG-SW2 */
> 	{"gpmc_ad1.gpio1_1", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},			/* DBG-SW3 */
> 	{"gpmc_ad2.gpio1_2", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},			/* DBG-SW4 */
> 	{"gpmc_ad7.gpmc_ad7", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT}, // RS(Half/full) 2015.01.16
> 	{"mii1_txd2.gpio0_17", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},/* RTC_INTn */
884,885c494
< 
< /* pinmux for led device */
---
> // pinmux for led device
887,890c496,501
< 	{"gpmc_ad4.gpio1_4", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_ad5.gpio1_5", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_ad6.gpio1_6", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_ad7.gpio1_7", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
---
> 	{"gpmc_ad10.gpio0_26", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* LED_ST0n */
> 	{"gpmc_ad11.gpio0_27", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* LED_ST1n */
>         // update 2015.03.02 3G power
> 	{"gpmc_ad4.gpio1_4",    OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // 3G power
> 	{"gpmc_ad5.gpio1_5",    OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT}, // 3G reset
> 	{"gpmc_oen_ren.gpio2_3", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},		/* F-LED_PWn */
894,895c505,522
< static struct pinmux_config gpio_ddr_vtt_enb_pin_mux[] = {
< 	{"ecap0_in_pwm0_out.gpio0_7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
---
> // MC341LAN2
> static struct pinmux_config mc341_lan1_model[] = {
> 	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},		/* SHUTDOWN-SWn */
> 	{"mcasp0_aclkr.gpio3_18", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},		/* PW_RST */
> 	{"gpmc_ad6.gpio1_6", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* LAN_SPEED_LED */
> 	{"mii1_txd3.gpio0_16", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},/* LAN_INTn */
> 	{NULL, 0},
> };
> static struct pinmux_config mc341_lan2_model[] = {
> 	{"mii1_txd3.gpio0_16", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* GPIO_INIT_END */
> 	{"mii1_rxdv.gpio3_4", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* SPI1_UFM-SN */
> 
> 	{"gpmc_ad3.gpio1_3", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},			/* SHUTDOWN-SWn */
> 	{"mii1_txclk.gpio3_9", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* PW_RST */
> 	{"mcasp0_fsr.gpio3_19", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},		/* LAN_SPEED_LED-A */
> 	{"mcasp0_axr1.gpio3_20", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},		/* LAN_SPEED_LED-B */
> 	{"mcasp0_aclkr.gpio3_18", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},		/* LAN-A_INTn */
> 	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},		/* LAN-B_INTn */
898a526
> 
912,1086d539
< /* Matrix GPIO Keypad Support for profile-0 only: TODO */
< 
< /* pinmux for keypad device */
< static struct pinmux_config matrix_keypad_pin_mux[] = {
< 	{"gpmc_a5.gpio1_21",  OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a6.gpio1_22",  OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
< 	{"gpmc_a9.gpio1_25",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_a10.gpio1_26", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_a11.gpio1_27", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{NULL, 0},
< };
< 
< /* Keys mapping */
< static const uint32_t am335x_evm_matrix_keys[] = {
< 	KEY(0, 0, KEY_MENU),
< 	KEY(1, 0, KEY_BACK),
< 	KEY(2, 0, KEY_LEFT),
< 
< 	KEY(0, 1, KEY_RIGHT),
< 	KEY(1, 1, KEY_POWER),
< 	KEY(2, 1, KEY_DOWN),
< };
< 
< const struct matrix_keymap_data am335x_evm_keymap_data = {
< 	.keymap      = am335x_evm_matrix_keys,
< 	.keymap_size = ARRAY_SIZE(am335x_evm_matrix_keys),
< };
< 
< static const unsigned int am335x_evm_keypad_row_gpios[] = {
< 	GPIO_TO_PIN(1, 25), GPIO_TO_PIN(1, 26), GPIO_TO_PIN(1, 27)
< };
< 
< static const unsigned int am335x_evm_keypad_col_gpios[] = {
< 	GPIO_TO_PIN(1, 21), GPIO_TO_PIN(1, 22)
< };
< 
< static struct matrix_keypad_platform_data am335x_evm_keypad_platform_data = {
< 	.keymap_data       = &am335x_evm_keymap_data,
< 	.row_gpios         = am335x_evm_keypad_row_gpios,
< 	.num_row_gpios     = ARRAY_SIZE(am335x_evm_keypad_row_gpios),
< 	.col_gpios         = am335x_evm_keypad_col_gpios,
< 	.num_col_gpios     = ARRAY_SIZE(am335x_evm_keypad_col_gpios),
< 	.active_low        = false,
< 	.debounce_ms       = 5,
< 	.col_scan_delay_us = 2,
< };
< 
< static struct platform_device am335x_evm_keyboard = {
< 	.name  = "matrix-keypad",
< 	.id    = -1,
< 	.dev   = {
< 		.platform_data = &am335x_evm_keypad_platform_data,
< 	},
< };
< 
< static void matrix_keypad_init(int evm_id, int profile)
< {
< 	int err;
< 
< 	setup_pin_mux(matrix_keypad_pin_mux);
< 	err = platform_device_register(&am335x_evm_keyboard);
< 	if (err) {
< 		pr_err("failed to register matrix keypad (2x3) device\n");
< 	}
< }
< 
< 
< /* pinmux for keypad device */
< static struct pinmux_config volume_keys_pin_mux[] = {
< 	{"spi0_sclk.gpio0_2",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"spi0_d0.gpio0_3",    OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{NULL, 0},
< };
< 
< /* Configure GPIOs for Volume Keys */
< static struct gpio_keys_button am335x_evm_volume_gpio_buttons[] = {
< 	{
< 		.code                   = KEY_VOLUMEUP,
< 		.gpio                   = GPIO_TO_PIN(0, 2),
< 		.active_low             = true,
< 		.desc                   = "volume-up",
< 		.type                   = EV_KEY,
< 		.wakeup                 = 1,
< 	},
< 	{
< 		.code                   = KEY_VOLUMEDOWN,
< 		.gpio                   = GPIO_TO_PIN(0, 3),
< 		.active_low             = true,
< 		.desc                   = "volume-down",
< 		.type                   = EV_KEY,
< 		.wakeup                 = 1,
< 	},
< };
< 
< static struct gpio_keys_platform_data am335x_evm_volume_gpio_key_info = {
< 	.buttons        = am335x_evm_volume_gpio_buttons,
< 	.nbuttons       = ARRAY_SIZE(am335x_evm_volume_gpio_buttons),
< };
< 
< static struct platform_device am335x_evm_volume_keys = {
< 	.name   = "gpio-keys",
< 	.id     = -1,
< 	.dev    = {
< 		.platform_data  = &am335x_evm_volume_gpio_key_info,
< 	},
< };
< 
< static void volume_keys_init(int evm_id, int profile)
< {
< 	int err;
< 
< 	setup_pin_mux(volume_keys_pin_mux);
< 	err = platform_device_register(&am335x_evm_volume_keys);
< 	if (err)
< 		pr_err("failed to register matrix keypad (2x3) device\n");
< }
< 
< /* pinmux for LCD cape keypad device */
< static struct pinmux_config lcd_cape_keys_pin_mux[] = {
< 	{"gpmc_a0.gpio1_16",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_a1.gpio1_17",    OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_csn2.gpio1_31",    OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{NULL, 0},
< };
< 
< /* Configure GPIOs for Volume Keys */
< static struct gpio_keys_button lcd_cape_gpio_buttons[] = {
< 	{
< 		.code                   = KEY_MENU,
< 		.gpio                   = GPIO_TO_PIN(1, 16),
< 		.active_low             = true,
< 		.desc                   = "menu",
< 		.type                   = EV_KEY,
< 		.wakeup                 = 1,
< 	},
< 	{
< 		.code                   = KEY_POWER,
< 		.gpio                   = GPIO_TO_PIN(1, 17),
< 		.active_low             = true,
< 		.desc                   = "power",
< 		.type                   = EV_KEY,
< 		.wakeup                 = 1,
< 	},
< 	{
< 		.code                   = KEY_BACK,
< 		.gpio                   = GPIO_TO_PIN(1, 31),
< 		.active_low             = true,
< 		.desc                   = "back",
< 		.type                   = EV_KEY,
< 		.wakeup                 = 1,
< 	},
< };
< 
< static struct gpio_keys_platform_data lcd_cape_gpio_key_info = {
< 	.buttons        = lcd_cape_gpio_buttons,
< 	.nbuttons       = ARRAY_SIZE(lcd_cape_gpio_buttons),
< };
< 
< static struct platform_device lcd_cape_keys = {
< 	.name   = "gpio-keys",
< 	.id     = -1,
< 	.dev    = {
< 		.platform_data  = &lcd_cape_gpio_key_info,
< 	},
< };
< 
< static void lcd_cape_keys_init(int evm_id, int profile)
< {
< 	int err;
< 
< 	setup_pin_mux(lcd_cape_keys_pin_mux);
< 	err = platform_device_register(&lcd_cape_keys);
< 	if (err)
< 		pr_err("failed to register lcd cape keypad device\n");
< }
1100c553
< 	am335x_evm_set_id(evm_id);
---
> 	mc341_set_id(evm_id);
1131,1164d583
< 
< /* pinmux for usb0 drvvbus */
< static struct pinmux_config usb0_pin_mux[] = {
< 	{"usb0_drvvbus.usb0_drvvbus",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* pinmux for usb1 drvvbus */
< static struct pinmux_config usb1_pin_mux[] = {
< 	{"usb1_drvvbus.usb1_drvvbus",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* pinmux for profibus */
< static struct pinmux_config profibus_pin_mux[] = {
< 	{"uart1_rxd.pr1_uart0_rxd_mux1", OMAP_MUX_MODE5 | AM33XX_PIN_INPUT},
< 	{"uart1_txd.pr1_uart0_txd_mux1", OMAP_MUX_MODE5 | AM33XX_PIN_OUTPUT},
< 	{"mcasp0_fsr.pr1_pru0_pru_r30_5", OMAP_MUX_MODE5 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for eCAP0 */
< static struct pinmux_config ecap0_pin_mux[] = {
< 	{"ecap0_in_pwm0_out.ecap0_in_pwm0_out",
< 		OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
< /* Module pin mux for eCAP */
< static struct pinmux_config ecap2_pin_mux[] = {
< 	{"mcasp0_ahclkr.ecap2_in_pwm2_out", AM33XX_PIN_OUTPUT},
< 	{NULL, 0},
< };
< 
1181,1190d599
< /* Module pin mux for wlan and bluetooth */
< static struct pinmux_config mmc2_wl12xx_pin_mux[] = {
< 	{"gpmc_a1.mmc2_dat0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_a2.mmc2_dat1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_a3.mmc2_dat2", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_ben1.mmc2_dat3", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_csn3.mmc2_cmd", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{"gpmc_clk.mmc2_clk", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},
< 	{NULL, 0},
< };
1193,1210c602,611
< 	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
< 	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT},
< 	{"uart1_rxd.uart1_rxd", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
< 	{"uart1_txd.uart1_txd", OMAP_MUX_MODE0 | AM33XX_PULL_ENBL},
< 	{NULL, 0},
< };
< 
< static struct pinmux_config wl12xx_pin_mux[] = {
< 	{"gpmc_a0.gpio1_16", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
< 	{"mcasp0_ahclkr.gpio3_17", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT_PULLUP},
< 	{NULL, 0},
<  };
< 
< static struct pinmux_config wl12xx_pin_mux_sk[] = {
< 	{"gpmc_wpn.gpio0_31", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT},
< 	{"gpmc_csn0.gpio1_29", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT_PULLUP},
< 	{"mcasp0_ahclkx.gpio3_21", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
---
> 	{"uart1_rxd.uart1_rxd", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},		/* UART1_RXD RS485 */
> 	{"uart1_txd.uart1_txd", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},			/* UART1_TXD RS485 */
> //	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},	/* UART1_RTSn RS485 */
> //	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},			/* UART1_CTSn RS485 */
> 	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},	/* UART1_RTSn RS485 */
> 	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},			/* UART1_CTSn RS485 */
> // update 2015.03.05 gpio1_7
> 	{"gpmc_ad7.gpio1_7", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},	/* UART1 mode */
> // update 2015.03.09 nmi set
> 	{"nmin.nmin", OMAP_MUX_MODE0 },	/* NMI in */
1214c615,616
< static bool backlight_enable;
---
> static struct pinmux_config dcan_mc341_pin_mux[] = {
> 	{"uart1_rxd.
1216,1283c618
< static void enable_ecap0(int evm_id, int profile)
< {
< 	backlight_enable = true;
< 	setup_pin_mux(ecap0_pin_mux);
< }
< 
< static void enable_ecap2(int evm_id, int profile)
< {
< 	backlight_enable = true;
< 	setup_pin_mux(ecap2_pin_mux);
< }
< 
< /* Setup pwm-backlight */
< static struct platform_device am335x_backlight = {
< 	.name           = "pwm-backlight",
< 	.id             = -1,
< 	.dev		= {
< 		.platform_data = &am335x_backlight_data0,
< 	},
< };
< 
< static struct pwmss_platform_data  pwm_pdata[3] = {
< 	{
< 		.version = PWM_VERSION_1,
< 	},
< 	{
< 		.version = PWM_VERSION_1,
< 	},
< 	{
< 		.version = PWM_VERSION_1,
< 	},
< };
< 
< static int __init backlight_init(void)
< {
< 	int status = 0;
< 
< 	if (backlight_enable) {
< 		int ecap_index = 0;
< 
< 		switch (am335x_evm_get_id()) {
< 		case GEN_PURP_EVM:
< 			ecap_index = 0;
< 			break;
< 		case EVM_SK:
< 			/*
< 			 * Invert polarity of PWM wave from ECAP to handle
< 			 * backlight intensity to pwm brightness
< 			 */
< 			ecap_index = 2;
< 			pwm_pdata[ecap_index].chan_attrib[0].inverse_pol = true;
< 			am335x_backlight.dev.platform_data =
< 				&am335x_backlight_data2;
< 			break;
< 		default:
< 			pr_err("%s: Error on attempting to enable backlight,"
< 				" not supported\n", __func__);
< 			return -EINVAL;
< 		}
< 
< 		am33xx_register_ecap(ecap_index, &pwm_pdata[ecap_index]);
< 		platform_device_register(&am335x_backlight);
< 	}
< 	return status;
< }
< late_initcall(backlight_init);
< 
< static int __init conf_disp_pll(int rate)
---
> static int __init conf_disp_pll(int rate)
1312,1314c647,649
< 	case GEN_PURP_EVM:
< 		lcdc_pdata = &TFC_S9700RTWV35TR_01B_pdata;
< 		break;
---
> //	case GEN_PURP_EVM:
> //		lcdc_pdata = &TFC_S9700RTWV35TR_01B_pdata;
> //		break;
1329,1435d663
< 
< static void bone_lcdc_init(int evm_id, int profile)
< {
< 
< 	pr_info("IN : %s \n", __FUNCTION__);
< 	setup_pin_mux(lcd_cape_pin_mux);
< 	setup_pin_mux(lcdc_pin_mux);
< 
< 	if (conf_disp_pll(300000000)) {
< 		pr_info("Failed configure display PLL, not attempting to"
< 				"register LCDC\n");
< 		return;
< 	}
< 
< 	gpio_request(BEAGLEBONE_LCD_BL, "BONE_LCD_BL");
< 	gpio_direction_output(BEAGLEBONE_LCD_BL, 1);
< 	gpio_request(BEAGLEBONE_LCD_AVDD_EN, "BONE_LCD_AVDD_EN");
< 	gpio_direction_output(BEAGLEBONE_LCD_AVDD_EN, 1);
< 
< 	if (am33xx_register_lcdc(&TFC_S9700RTWV35TR_01B_bone_lcd_cape_pdata))
< 		pr_info("Failed to register LCDC device\n");
< 
< 
< 	pr_info("Setup LCD display\n");
< 	return;
< }
< 
< static void vnc_lcdc_init(int evm_id, int profile)
< {
< 	setup_pin_mux(lcdc_pin_mux);
< 
< 	if (conf_disp_pll(300000000)) {
< 		pr_info("Failed configure display PLL, not attempting to"
< 				"register LCDC\n");
< 		return;
< 	}
< 	if (am33xx_register_lcdc(&Sharp_LCD035Q3DG01_pdata))
< 		pr_info("Failed to register LCDC device\n");
< 	return;
< }
< 
< #define BEAGLEBONEDVI_PDn  GPIO_TO_PIN(1, 7)
< 
< static void dvi_init(int evm_id, int profile)
< {
< 	pr_info("IN : %s \n", __FUNCTION__);
< 	setup_pin_mux(dvi_pin_mux);
< 	gpio_request(BEAGLEBONEDVI_PDn, "DVI_PDn");
< 	gpio_direction_output(BEAGLEBONEDVI_PDn, 1);
< 
< 	/* we are being stupid and setting pixclock
< 	   from here instead of da8xx-fb.c */
< 	if (conf_disp_pll(560000000)) {
< 		pr_info("Failed to set pixclock to 56000000, not attempting to"
< 				"register DVI adapter\n");
< 		return;
< 	}
< 
< 	if (am33xx_register_lcdc(&dvi_pdata))
< 		pr_info("Failed to register BeagleBoardToys DVI adapter\n");
< 
< 	pr_info("Setup DVI display\n");
< 	return;
< }
< 
< static void tsc_init(int evm_id, int profile)
< {
< 	int err;
< 
< 	setup_pin_mux(tsc_pin_mux);
< 	err = am33xx_register_tsc(&am335x_touchscreen_data);
< 	if (err)
< 		pr_err("failed to register touchscreen device\n");
< }
< 
< static void lcd_cape_tsc_init(int evm_id, int profile)
< {
< 	int err;
< 
< 	pr_info("IN : %s \n", __FUNCTION__);
< 	setup_pin_mux(tsc_pin_mux);
< 	err = am33xx_register_tsc (&am335x_touchscreen_data);
< 	if (err)
< 		pr_err("failed to register touchscreen device\n");
< 
< 	pr_info("Setup LCD cape touchscreen\n");
< 
< }
< 
< static void rgmii1_init(int evm_id, int profile)
< {
< 	setup_pin_mux(rgmii1_pin_mux);
< 	return;
< }
< 
< static void rgmii2_init(int evm_id, int profile)
< {
< 	setup_pin_mux(rgmii2_pin_mux);
< 	return;
< }
< 
< static void mii1_init(int evm_id, int profile)
< {
< 	setup_pin_mux(mii1_pin_mux);
< 	return;
< }
< 
1438a667
> // printk(KERN_WARNING "[%s](%d)rmii1_init in!!!",__FILE__,__LINE__); // 12.23
1442,1452d670
< static void usb0_init(int evm_id, int profile)
< {
< 	setup_pin_mux(usb0_pin_mux);
< 	return;
< }
< 
< static void usb1_init(int evm_id, int profile)
< {
< 	setup_pin_mux(usb1_pin_mux);
< 	return;
< }
1454,1531d671
< /* setup uart3 */
< static void uart3_init(int evm_id, int profile)
< {
< 	setup_pin_mux(uart3_pin_mux);
< 	return;
< }
< 
< /* setup uart2 */
< static void uart2_init(int evm_id, int profile)
< {
< 	setup_pin_mux(uart2_pin_mux);
< 	return;
< }
< 
< /*
<  * gpio0_7 was driven HIGH in u-boot before DDR configuration
<  *
<  * setup gpio0_7 for EVM-SK 1.2
<  */
< static void gpio_ddr_vtt_enb_init(int evm_id, int profile)
< {
< 	setup_pin_mux(gpio_ddr_vtt_enb_pin_mux);
< 	return;
< }
< 
< /* setup haptics */
< #define HAPTICS_MAX_FREQ 250
< static void haptics_init(int evm_id, int profile)
< {
< 	setup_pin_mux(haptics_pin_mux);
< 	pwm_pdata[2].chan_attrib[1].max_freq = HAPTICS_MAX_FREQ;
< 	am33xx_register_ehrpwm(2, &pwm_pdata[2]);
< }
< 
< /* NAND partition information */
< static struct mtd_partition am335x_nand_partitions[] = {
< /* All the partition sizes are listed in terms of NAND block size */
< 	{
< 		.name           = "SPL",
< 		.offset         = 0,			/* Offset = 0x0 */
< 		.size           = SZ_128K,
< 	},
< 	{
< 		.name           = "SPL.backup1",
< 		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x20000 */
< 		.size           = SZ_128K,
< 	},
< 	{
< 		.name           = "SPL.backup2",
< 		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x40000 */
< 		.size           = SZ_128K,
< 	},
< 	{
< 		.name           = "SPL.backup3",
< 		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x60000 */
< 		.size           = SZ_128K,
< 	},
< 	{
< 		.name           = "U-Boot",
< 		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x80000 */
< 		.size           = 15 * SZ_128K,
< 	},
< 	{
< 		.name           = "U-Boot Env",
< 		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x260000 */
< 		.size           = 1 * SZ_128K,
< 	},
< 	{
< 		.name           = "Kernel",
< 		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x280000 */
< 		.size           = 40 * SZ_128K,
< 	},
< 	{
< 		.name           = "File System",
< 		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x780000 */
< 		.size           = MTDPART_SIZ_FULL,
< 	},
< };
1545c685
< 		.size       = 2 * SZ_128K,
---
> 		.size       = 4 * SZ_128K,
1549,1550c689,690
< 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0x60000 */
< 		.size       = 2 * SZ_4K,
---
> 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0xa0000 */
> 		.size       = 2 * SZ_128K,
1554,1555c694,695
< 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0x62000 */
< 		.size       = 28 * SZ_128K,
---
> 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0xE0000 */
> 		.size       = 27 * SZ_128K,
1558,1560c698,705
< 		.name       = "File System",
< 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0x3E2000 */
< 		.size       = MTDPART_SIZ_FULL,		/* size ~= 4.1 MiB */
---
> 		.name       = "Root File System",
> 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0x442000 */
> 		.size       = 76 * SZ_128K,		/* size ~= 10 MiB */
> 	},
> 	{
> 		.name       = "APL Area",
> 		.offset     = MTDPART_OFS_APPEND,	/* Offset = 0xDD0000 */
> 		.size       = MTDPART_SIZ_FULL,		/* size ~= 20 MiB */
1564,1565c709,711
< static const struct flash_platform_data am335x_spi_flash = {
< 	.type      = "w25q64",
---
> static const struct flash_platform_data mc341_spi_flash = {
> 	// .type      = "w25q64", // org
> 	.type      = "n25q256a",
1571,1975c717
< /*
<  * SPI Flash works at 80Mhz however SPI Controller works at 48MHz.
<  * So setup Max speed to be less than that of Controller speed
<  */
< static struct spi_board_info am335x_spi0_slave_info[] = {
< 	{
< 		.modalias      = "m25p80",
< 		.platform_data = &am335x_spi_flash,
< 		.irq           = -1,
< 		.max_speed_hz  = 24000000,
< 		.bus_num       = 1,
< 		.chip_select   = 0,
< 	},
< };
< 
< static struct spi_board_info am335x_spi1_slave_info[] = {
< 	{
< 		.modalias      = "m25p80",
< 		.platform_data = &am335x_spi_flash,
< 		.irq           = -1,
< 		.max_speed_hz  = 12000000,
< 		.bus_num       = 2,
< 		.chip_select   = 0,
< 	},
< };
< 
< static struct gpmc_timings am335x_nand_timings = {
< 	.sync_clk = 0,
< 
< 	.cs_on = 0,
< 	.cs_rd_off = 44,
< 	.cs_wr_off = 44,
< 
< 	.adv_on = 6,
< 	.adv_rd_off = 34,
< 	.adv_wr_off = 44,
< 	.we_off = 40,
< 	.oe_off = 54,
< 
< 	.access = 64,
< 	.rd_cycle = 82,
< 	.wr_cycle = 82,
< 
< 	.wr_access = 40,
< 	.wr_data_mux_bus = 0,
< };
< 
< static void evm_nand_init(int evm_id, int profile)
< {
< 	struct omap_nand_platform_data *pdata;
< 	struct gpmc_devices_info gpmc_device[2] = {
< 		{ NULL, 0 },
< 		{ NULL, 0 },
< 	};
< 
< 	setup_pin_mux(nand_pin_mux);
< 	pdata = omap_nand_init(am335x_nand_partitions,
< 		ARRAY_SIZE(am335x_nand_partitions), 0, 0,
< 		&am335x_nand_timings);
< 	if (!pdata)
< 		return;
< 	pdata->ecc_opt =OMAP_ECC_BCH8_CODE_HW;
< 	pdata->elm_used = true;
< 	gpmc_device[0].pdata = pdata;
< 	gpmc_device[0].flag = GPMC_DEVICE_NAND;
< 
< 	omap_init_gpmc(gpmc_device, sizeof(gpmc_device));
< 	omap_init_elm();
< }
< 
< /* TPS65217 voltage regulator support */
< 
< /* 1.8V */
< static struct regulator_consumer_supply tps65217_dcdc1_consumers[] = {
< 	{
< 		.supply = "vdds_osc",
< 	},
< 	{
< 		.supply = "vdds_pll_ddr",
< 	},
< 	{
< 		.supply = "vdds_pll_mpu",
< 	},
< 	{
< 		.supply = "vdds_pll_core_lcd",
< 	},
< 	{
< 		.supply = "vdds_sram_mpu_bb",
< 	},
< 	{
< 		.supply = "vdds_sram_core_bg",
< 	},
< 	{
< 		.supply = "vdda_usb0_1p8v",
< 	},
< 	{
< 		.supply = "vdds_ddr",
< 	},
< 	{
< 		.supply = "vdds",
< 	},
< 	{
< 		.supply = "vdds_hvx_1p8v",
< 	},
< 	{
< 		.supply = "vdda_adc",
< 	},
< 	{
< 		.supply = "ddr2",
< 	},
< };
< 
< /* 1.1V */
< static struct regulator_consumer_supply tps65217_dcdc2_consumers[] = {
< 	{
< 		.supply = "vdd_mpu",
< 	},
< };
< 
< /* 1.1V */
< static struct regulator_consumer_supply tps65217_dcdc3_consumers[] = {
< 	{
< 		.supply = "vdd_core",
< 	},
< };
< 
< /* 1.8V LDO */
< static struct regulator_consumer_supply tps65217_ldo1_consumers[] = {
< 	{
< 		.supply = "vdds_rtc",
< 	},
< };
< 
< /* 3.3V LDO */
< static struct regulator_consumer_supply tps65217_ldo2_consumers[] = {
< 	{
< 		.supply = "vdds_any_pn",
< 	},
< };
< 
< /* 3.3V LDO */
< static struct regulator_consumer_supply tps65217_ldo3_consumers[] = {
< 	{
< 		.supply = "vdds_hvx_ldo3_3p3v",
< 	},
< 	{
< 		.supply = "vdda_usb0_3p3v",
< 	},
< };
< 
< /* 3.3V LDO */
< static struct regulator_consumer_supply tps65217_ldo4_consumers[] = {
< 	{
< 		.supply = "vdds_hvx_ldo4_3p3v",
< 	},
< };
< 
< /*
<  * FIXME: Some BeagleBones reuire a ramp_delay to settle down the set
<  * voltage from 0.95v to 1.25v. By default a minimum of 70msec is set
<  * based on experimentation. This will be removed/modified to exact
<  * value, once the root cause is known.
<  *
<  * The reason for extended ramp time requirement on BeagleBone is not
<  * known and the delay varies from board - board, if the board hangs
<  * with this 70msec delay then try to increase the value.
<  */
< static struct tps65217_rdelay dcdc2_ramp_delay = {
< 	.ramp_delay = 70000,
< };
< 
< static struct regulator_init_data tps65217_regulator_data[] = {
< 	/* dcdc1 */
< 	{
< 		.constraints = {
< 			.min_uV = 900000,
< 			.max_uV = 1800000,
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc1_consumers),
< 		.consumer_supplies = tps65217_dcdc1_consumers,
< 	},
< 
< 	/* dcdc2 */
< 	{
< 		.constraints = {
< 			.min_uV = 900000,
< 			.max_uV = 3300000,
< 			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
< 				REGULATOR_CHANGE_STATUS),
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc2_consumers),
< 		.consumer_supplies = tps65217_dcdc2_consumers,
< 		.driver_data = &dcdc2_ramp_delay,
< 	},
< 
< 	/* dcdc3 */
< 	{
< 		.constraints = {
< 			.min_uV = 900000,
< 			.max_uV = 1500000,
< 			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
< 				REGULATOR_CHANGE_STATUS),
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_dcdc3_consumers),
< 		.consumer_supplies = tps65217_dcdc3_consumers,
< 	},
< 
< 	/* ldo1 */
< 	{
< 		.constraints = {
< 			.min_uV = 1000000,
< 			.max_uV = 3300000,
< 			.valid_ops_mask = REGULATOR_CHANGE_STATUS,
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo1_consumers),
< 		.consumer_supplies = tps65217_ldo1_consumers,
< 	},
< 
< 	/* ldo2 */
< 	{
< 		.constraints = {
< 			.min_uV = 900000,
< 			.max_uV = 3300000,
< 			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
< 				REGULATOR_CHANGE_STATUS),
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo2_consumers),
< 		.consumer_supplies = tps65217_ldo2_consumers,
< 	},
< 
< 	/* ldo3 */
< 	{
< 		.constraints = {
< 			.min_uV = 1800000,
< 			.max_uV = 3300000,
< 			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
< 				REGULATOR_CHANGE_STATUS),
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo3_consumers),
< 		.consumer_supplies = tps65217_ldo3_consumers,
< 	},
< 
< 	/* ldo4 */
< 	{
< 		.constraints = {
< 			.min_uV = 1800000,
< 			.max_uV = 3300000,
< 			.valid_ops_mask = (REGULATOR_CHANGE_VOLTAGE |
< 				REGULATOR_CHANGE_STATUS),
< 			.boot_on = 1,
< 			.always_on = 1,
< 		},
< 		.num_consumer_supplies = ARRAY_SIZE(tps65217_ldo4_consumers),
< 		.consumer_supplies = tps65217_ldo4_consumers,
< 	},
< };
< 
< static struct tps65217_board beaglebone_tps65217_info = {
< 	.tps65217_init_data = &tps65217_regulator_data[0],
< };
< 
< static struct lis3lv02d_platform_data lis331dlh_pdata = {
< 	.click_flags = LIS3_CLICK_SINGLE_X |
< 			LIS3_CLICK_SINGLE_Y |
< 			LIS3_CLICK_SINGLE_Z,
< 	.wakeup_flags = LIS3_WAKEUP_X_LO | LIS3_WAKEUP_X_HI |
< 			LIS3_WAKEUP_Y_LO | LIS3_WAKEUP_Y_HI |
< 			LIS3_WAKEUP_Z_LO | LIS3_WAKEUP_Z_HI,
< 	.irq_cfg = LIS3_IRQ1_CLICK | LIS3_IRQ2_CLICK,
< 	.wakeup_thresh	= 10,
< 	.click_thresh_x = 10,
< 	.click_thresh_y = 10,
< 	.click_thresh_z = 10,
< 	.g_range	= 2,
< 	.st_min_limits[0] = 120,
< 	.st_min_limits[1] = 120,
< 	.st_min_limits[2] = 140,
< 	.st_max_limits[0] = 550,
< 	.st_max_limits[1] = 550,
< 	.st_max_limits[2] = 750,
< };
< 
< static struct i2c_board_info lis331dlh_i2c_boardinfo[] = {
< 	{
< 		I2C_BOARD_INFO("lis331dlh", 0x18),
< 		.platform_data = &lis331dlh_pdata,
< 	},
< };
< 
< static void lis331dlh_init(int evm_id, int profile)
< {
< 	struct i2c_adapter *adapter;
< 	struct i2c_client *client;
< 	unsigned int i2c_instance;
< 
< 	switch (evm_id) {
< 	case GEN_PURP_EVM:
< 		i2c_instance = 2;
< 		break;
< 	case EVM_SK:
< 		i2c_instance = 1;
< 		break;
< 	default:
< 		pr_err("lis331dlh is not supported on this evm (%d)\n", evm_id);
< 		return;
< 	}
< 
< 	/* I2C adapter request */
< 	adapter = i2c_get_adapter(i2c_instance);
< 	if (!adapter) {
< 		pr_err("failed to get adapter i2c%u\n", i2c_instance);
< 		return;
< 	}
< 
< 	client = i2c_new_device(adapter, lis331dlh_i2c_boardinfo);
< 	if (!client)
< 		pr_err("failed to register lis331dlh to i2c%u\n", i2c_instance);
< 
< 	i2c_put_adapter(adapter);
< }
< 
< static struct i2c_board_info am335x_i2c1_boardinfo[] = {
< 	{
< 		I2C_BOARD_INFO("tlv320aic3x", 0x1b),
< 	},
< 	{
< 		I2C_BOARD_INFO("tsl2550", 0x39),
< 	},
< 	{
< 		I2C_BOARD_INFO("tmp275", 0x48),
< 	},
< };
< 
< static void i2c1_init(int evm_id, int profile)
< {
< 	setup_pin_mux(i2c1_pin_mux);
< 	omap_register_i2c_bus(2, 100, am335x_i2c1_boardinfo,
< 			ARRAY_SIZE(am335x_i2c1_boardinfo));
< 	return;
< }
< 
< static struct at24_platform_data bone_daughter_board_eeprom_info;
< 
< static struct i2c_board_info am335x_i2c2_boardinfo[] = {
< 	{
< 		/* Daughter Board EEPROM */
< 		I2C_BOARD_INFO("24c256", LCD_CAPE_I2C_ADDR),
< 		.platform_data  = &bone_daughter_board_eeprom_info,
< 	},
< };
< 
< static void i2c2_init(int evm_id, int profile)
< {
< 	setup_pin_mux(i2c2_pin_mux);
< 	omap_register_i2c_bus(3, 100, am335x_i2c2_boardinfo,
< 			ARRAY_SIZE(am335x_i2c2_boardinfo));
< 	return;
< }
< 
< /* Setup McASP 1 */
< static void mcasp1_init(int evm_id, int profile)
< {
< 	/* Configure McASP */
< 	setup_pin_mux(mcasp1_pin_mux);
< 	switch (evm_id) {
< 	case EVM_SK:
< 		am335x_register_mcasp(&am335x_evm_sk_snd_data1, 1);
< 		break;
< 	default:
< 		am335x_register_mcasp(&am335x_evm_snd_data1, 1);
< 	}
< 
< 	return;
< }
< 
< static void mmc1_init(int evm_id, int profile)
< {
< 	setup_pin_mux(mmc1_common_pin_mux);
< 	setup_pin_mux(mmc1_dat4_7_pin_mux);
< 	setup_pin_mux(mmc1_wp_only_pin_mux);
< 	setup_pin_mux(mmc1_cd_only_pin_mux);
< 
< 	am335x_mmc[1].mmc = 2;
< 	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA;
< 	am335x_mmc[1].gpio_cd = GPIO_TO_PIN(2, 2);
< 	am335x_mmc[1].gpio_wp = GPIO_TO_PIN(1, 29);
< 	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
< 
< 	/* mmc will be initialized when mmc0_init is called */
< 	return;
< }
< 
< static void mmc1_wl12xx_init(int evm_id, int profile)
---
> static void uart1_wl12xx_init(int evm_id, int profile)
1977,2001c719
< 	setup_pin_mux(mmc1_common_pin_mux);
< 	am335x_mmc[1].mmc = 2;
< 	am335x_mmc[1].name = "wl1271";
< 	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
< 	am335x_mmc[1].nonremovable = true;
< 	am335x_mmc[1].pm_caps = MMC_PM_KEEP_POWER;
< 	am335x_mmc[1].gpio_cd = -EINVAL;
< 	am335x_mmc[1].gpio_wp = -EINVAL;
< 	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
< }
< 
< static void mmc2_wl12xx_init(int evm_id, int profile)
< {
< 	setup_pin_mux(mmc2_wl12xx_pin_mux);
< 
< 	am335x_mmc[1].mmc = 3;
< 	am335x_mmc[1].name = "wl1271";
< 	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD;
< 	am335x_mmc[1].nonremovable = true;
< 	am335x_mmc[1].gpio_cd = -EINVAL;
< 	am335x_mmc[1].gpio_wp = -EINVAL;
< 	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
< 
< 	/* mmc will be initialized when mmc0_init is called */
< 	return;
---
> 	setup_pin_mux(uart1_wl12xx_pin_mux);
2004c722,723
< static void uart1_wl12xx_init(int evm_id, int profile)
---
> // update 2015.07.02
> static void dcan_mc341_init(int evm_id, int profile)
2006c725
< 	setup_pin_mux(uart1_wl12xx_pin_mux);
---
> 	setup_pin_mux(dcan_mc341_pin_mux);
2073,2148c792
< };
< 
< static struct platform_device wl12xx_device = {
< 	.name		= "kim",
< 	.id		= -1,
< 	.dev.platform_data = &wilink_pdata,
< };
< 
< static struct platform_device btwilink_device = {
< 	.name = "btwilink",
< 	.id = -1,
< };
< 
< static inline void __init am335xevm_init_btwilink(void)
< {
< 	pr_info("am335xevm: bt init\n");
< 
< 	platform_device_register(&wl12xx_device);
< 	platform_device_register(&btwilink_device);
< }
< #endif
< 
< static void wl12xx_bluetooth_enable(void)
< {
< #ifndef CONFIG_TI_ST
< 	int status = gpio_request(am335xevm_wlan_data.bt_enable_gpio,
< 		"bt_en\n");
< 	if (status < 0)
< 		pr_err("Failed to request gpio for bt_enable");
< 
< 	pr_info("Configure Bluetooth Enable pin...\n");
< 	gpio_direction_output(am335xevm_wlan_data.bt_enable_gpio, 0);
< #else
< 	am335xevm_init_btwilink();
< #endif
< }
< 
< static int wl12xx_set_power(struct device *dev, int slot, int on, int vdd)
< {
< 	if (on) {
< 		gpio_direction_output(am335xevm_wlan_data.wlan_enable_gpio, 1);
< 		mdelay(70);
< 	} else {
< 		gpio_direction_output(am335xevm_wlan_data.wlan_enable_gpio, 0);
< 	}
< 
< 	return 0;
< }
< 
< static void wl12xx_init(int evm_id, int profile)
< {
< 	struct device *dev;
< 	struct omap_mmc_platform_data *pdata;
< 	int ret;
< 
< 	if (evm_id == EVM_SK) {
< 		am335xevm_wlan_data.wlan_enable_gpio = GPIO_TO_PIN(1, 29);
< 		am335xevm_wlan_data.bt_enable_gpio = GPIO_TO_PIN(3, 21);
< 		am335xevm_wlan_data.irq =
< 				OMAP_GPIO_IRQ(AM335XEVM_SK_WLAN_IRQ_GPIO);
< 		am335xevm_wlan_data.platform_quirks =
< 				WL12XX_PLATFORM_QUIRK_EDGE_IRQ;
< 		setup_pin_mux(wl12xx_pin_mux_sk);
< 	} else {
< 		setup_pin_mux(wl12xx_pin_mux);
< 	}
< 	wl12xx_bluetooth_enable();
< 
< 	if (wl12xx_set_platform_data(&am335xevm_wlan_data))
< 		pr_err("error setting wl12xx data\n");
< 
< 	dev = am335x_mmc[1].dev;
< 	if (!dev) {
< 		pr_err("wl12xx mmc device initialization failed\n");
< 		goto out;
< 	}
---
> };
2150,2154c794,798
< 	pdata = dev->platform_data;
< 	if (!pdata) {
< 		pr_err("Platfrom data of wl12xx device not set\n");
< 		goto out;
< 	}
---
> static struct platform_device wl12xx_device = {
> 	.name		= "kim",
> 	.id		= -1,
> 	.dev.platform_data = &wilink_pdata,
> };
2156,2161c800,803
< 	ret = gpio_request_one(am335xevm_wlan_data.wlan_enable_gpio,
< 		GPIOF_OUT_INIT_LOW, "wlan_en");
< 	if (ret) {
< 		pr_err("Error requesting wlan enable gpio: %d\n", ret);
< 		goto out;
< 	}
---
> static struct platform_device btwilink_device = {
> 	.name = "btwilink",
> 	.id = -1,
> };
2162a805,807
> static inline void __init am335xevm_init_btwilink(void)
> {
> 	pr_info("am335xevm: bt init\n");
2164,2166c809,810
< 	pdata->slots[0].set_power = wl12xx_set_power;
< out:
< 	return;
---
> 	platform_device_register(&wl12xx_device);
> 	platform_device_register(&btwilink_device);
2167a812
> #endif
2169,2189d813
< static void d_can_init(int evm_id, int profile)
< {
< 	switch (evm_id) {
< 	case IND_AUT_MTR_EVM:
< 		if ((profile == PROFILE_0) || (profile == PROFILE_1)) {
< 			setup_pin_mux(d_can_ia_pin_mux);
< 			/* Instance Zero */
< 			am33xx_d_can_init(0);
< 		}
< 		break;
< 	case GEN_PURP_EVM:
< 		if (profile == PROFILE_1) {
< 			setup_pin_mux(d_can_gp_pin_mux);
< 			/* Instance One */
< 			am33xx_d_can_init(1);
< 		}
< 		break;
< 	default:
< 		break;
< 	}
< }
2192a817,818
> // printk(KERN_WARNING "[%s](%d)mmc0_init in!!!",__FILE__,__LINE__); // 12.23
> /* 1231 
2206,2268c832
< 
< 	omap2_hsmmc_init(am335x_mmc);
< 	return;
< }
< 
< static struct i2c_board_info tps65217_i2c_boardinfo[] = {
< 	{
< 		I2C_BOARD_INFO("tps65217", TPS65217_I2C_ID),
< 		.platform_data  = &beaglebone_tps65217_info,
< 	},
< };
< 
< static void tps65217_init(int evm_id, int profile)
< {
< 	struct i2c_adapter *adapter;
< 	struct i2c_client *client;
< 	struct device *mpu_dev;
< 	struct tps65217 *tps;
< 	unsigned int val;
< 	int ret;
< 
< 	mpu_dev = omap_device_get_by_hwmod_name("mpu");
< 	if (!mpu_dev)
< 		pr_warning("%s: unable to get the mpu device\n", __func__);
< 
< 	/* I2C1 adapter request */
< 	adapter = i2c_get_adapter(1);
< 	if (!adapter) {
< 		pr_err("failed to get adapter i2c1\n");
< 		return;
< 	}
< 
< 	client = i2c_new_device(adapter, tps65217_i2c_boardinfo);
< 	if (!client)
< 		pr_err("failed to register tps65217 to i2c1\n");
< 
< 	i2c_put_adapter(adapter);
< 
< 	tps = (struct tps65217 *)i2c_get_clientdata(client);
< 
< 	ret = tps65217_reg_read(tps, TPS65217_REG_STATUS, &val);
< 	if (ret) {
< 		pr_err("failed to read tps65217 status reg\n");
< 		return;
< 	}
< 
< 	if (!(val & TPS65217_STATUS_ACPWR)) {
< 		/* If powered by USB then disable OPP120 and OPPTURBO */
< 		pr_info("Maximum current provided by the USB port is 500mA"
< 			" which is not sufficient\nwhen operating @OPP120 and"
< 			" OPPTURBO. The current requirement for some\nuse-cases"
< 			" using OPP100 might also exceed the maximum current"
< 			" that the\nUSB port can provide. Unless you are fully"
< 			" confident that the current\nrequirements for OPP100"
< 			" use-case don't exceed the USB limits, switching\nto"
< 			" AC power is recommended.\n");
< 		opp_disable(mpu_dev, 600000000);
< 		opp_disable(mpu_dev, 720000000);
< 	}
< }
< 
< static void mmc0_no_cd_init(int evm_id, int profile)
< {
---
> */
2270c834
< 	setup_pin_mux(mmc0_wp_only_pin_mux);
---
> 	setup_pin_mux(mmc0_cd_only_pin_mux);
2272c836
< 	omap2_hsmmc_init(am335x_mmc);
---
> 	omap2_hsmmc_init(mc341_mmc);
2276,2282c840,842
< /* Configure GPIOs for GPIO Keys */
< static struct gpio_keys_button am335x_evm_gpio_buttons[] = {
< 	{
< 		.code                   = BTN_0,
< 		.gpio                   = GPIO_TO_PIN(2, 3),
< 		.desc                   = "SW1",
< 	},
---
> 
> // Configure GPIOs for GPIO Keys 
> static struct gpio_keys_button mc341_gpio_buttons[] = {
2285c845
< 		.gpio                   = GPIO_TO_PIN(2, 2),
---
> 		.gpio                   = GPIO_TO_PIN(1, 0),
2290c850
< 		.gpio                   = GPIO_TO_PIN(0, 30),
---
> 		.gpio                   = GPIO_TO_PIN(1, 1),
2296c856
< 		.gpio                   = GPIO_TO_PIN(2, 5),
---
> 		.gpio                   = GPIO_TO_PIN(2, 2),
2301,2303c861,863
< static struct gpio_keys_platform_data am335x_evm_gpio_key_info = {
< 	.buttons        = am335x_evm_gpio_buttons,
< 	.nbuttons       = ARRAY_SIZE(am335x_evm_gpio_buttons),
---
> static struct gpio_keys_platform_data mc341_gpio_key_info = {
> 	.buttons        = mc341_gpio_buttons,
> 	.nbuttons       = ARRAY_SIZE(mc341_gpio_buttons),
2306c866
< static struct platform_device am335x_evm_gpio_keys = {
---
> static struct platform_device mc341_gpio_keys = {
2310c870
< 		.platform_data  = &am335x_evm_gpio_key_info,
---
> 		.platform_data  = &mc341_gpio_key_info,
2313d872
< 
2319c878
< 	err = platform_device_register(&am335x_evm_gpio_keys);
---
> 	err = platform_device_register(&mc341_gpio_keys);
2326,2327c885,895
< 		.name			= "am335x:EVM_SK:usr0",
< 		.gpio			= GPIO_TO_PIN(1, 4),	/* D1 */
---
> 		.name			= "MC341B-00:LED_ST0n",
> 		.gpio			= GPIO_TO_PIN(0, 26),
> 	},
> 	{
> 		.name			= "MC341B-00:LED_ST1n",
> 		.gpio			= GPIO_TO_PIN(0, 27),
> 	},
> /*
> 	{
> 		.name			= "MC341B-00:LAN_SPEED_LED",
> 		.gpio			= GPIO_TO_PIN(1, 6),
2328a897
> */
2330,2331c899,900
< 		.name			= "am335x:EVM_SK:usr1",
< 		.gpio			= GPIO_TO_PIN(1, 5),	/* D2 */
---
> 		.name			= "MC341B-00:F-LED_PWn",
> 		.gpio			= GPIO_TO_PIN(2, 3),
2334,2336c903,904
< 		.name			= "am335x:EVM_SK:mmc0",
< 		.gpio			= GPIO_TO_PIN(1, 7),	/* D3 */
< 		.default_trigger	= "mmc0",
---
> 		.name			= "MC341B-00:3G_PWn",
> 		.gpio			= GPIO_TO_PIN(1, 4),
2339,2341c907,908
< 		.name			= "am335x:EVM_SK:heartbeat",
< 		.gpio			= GPIO_TO_PIN(1, 6),	/* D4 */
< 		.default_trigger	= "heartbeat",
---
> 		.name			= "MC341B-00:3G_Reset",
> 		.gpio			= GPIO_TO_PIN(1, 5),
2357d923
< 
2368,2369c934,993
< /* setup spi0 */
< static void spi0_init(int evm_id, int profile)
---
> /* Module pin mux for SPI0 fash */
> static struct pinmux_config spi0_pin_mux[] = {
> 	{"spi0_sclk.spi0_sclk", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},		/* SPI0_SCLK ROM[CLK] */
> 	{"spi0_d0.spi0_d0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},			/* SPI0_D0 ROM[MISO] */
> 	{"spi0_d1.spi0_d1", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},			/* SPI0_D1 ROM[MOSI] */
> 	{"spi0_cs0.spi0_cs0", OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},		/* SPI0_CS0 ROM[CS] */
> 	{"mii1_rxclk.gpio3_10", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},			/* ROM_WPn */
> 	{NULL, 0},
> };
> static struct spi_board_info mc341_spi0_slave_info[] = {
> 	{
> 		.modalias      = "m25p80",
> 		// .modalias      = "spidev", // for spidev
> 		// .mode=SPI_MODE_3,	// for spidev
> 		.platform_data = &mc341_spi_flash,
> 		.irq           = -1,
> 		.max_speed_hz  = 24000000,
> 		.bus_num       = 1,
> 		.chip_select   = 0,
> 	},
> 	// ad
> // update 2015.02.12 max_speed 6Mbps
>         {
>                 .modalias       = "spidev",
>               //  .max_speed_hz   = 48000000, //48 Mbps
>               //  .max_speed_hz   = 24000000, //24 Mbps
>                 .max_speed_hz   = 6000000, //6 Mbps
>                 .bus_num        = 2,
>                 .chip_select    = 0,
> /*                .mode = SPI_MODE_3, */
> //                .mode = SPI_MODE_1 | SPI_CS_HIGH,
> 		// update 2015.02.18 SPI2.0
>                 .mode = SPI_MODE_2,
>         },
> // update 2015.02.09 spidev test
> // update 2015.02.12 max_speed 6Mbps
>         { // cpld
>                 .modalias       = "spidev",
>               //  .max_speed_hz   = 48000000, //48 Mbps
>               //  .max_speed_hz   = 24000000, //24 Mbps
>                 .max_speed_hz   = 6000000, //6 Mbps
>                 .bus_num        = 2,
>                 .chip_select    = 1,
> /*                .mode = SPI_MODE_3, */
> //                .mode = SPI_MODE_1 | SPI_CS_HIGH,
> //                 .mode = SPI_MODE_2 | SPI_CS_HIGH,
>                 .mode = SPI_MODE_2,
>         },
> };
> /* pinmux for usb0 drvvbus */
> static struct pinmux_config usb0_pin_mux[] = {
> 	{"usb0_drvvbus.usb0_drvvbus",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
> 	{NULL, 0},
> };
> /* pinmux for usb1 drvvbus */
> static struct pinmux_config usb1_pin_mux[] = {
> 	{"usb1_drvvbus.usb1_drvvbus",    OMAP_MUX_MODE0 | AM33XX_PIN_OUTPUT},
> 	{NULL, 0},
> };
> static void usb0_init(int evm_id, int profile)
2371,2373c995
< 	setup_pin_mux(spi0_pin_mux);
< 	spi_register_board_info(am335x_spi0_slave_info,
< 			ARRAY_SIZE(am335x_spi0_slave_info));
---
> 	setup_pin_mux(usb0_pin_mux);
2377,2378c999
< /* setup spi1 */
< static void spi1_init(int evm_id, int profile)
---
> static void usb1_init(int evm_id, int profile)
2380,2382c1001
< 	setup_pin_mux(spi1_pin_mux);
< 	spi_register_board_info(am335x_spi1_slave_info,
< 			ARRAY_SIZE(am335x_spi1_slave_info));
---
> 	setup_pin_mux(usb1_pin_mux);
2386,2395c1005,1006
< 
< static int beaglebone_phy_fixup(struct phy_device *phydev)
< {
< 	phydev->supported &= ~(SUPPORTED_100baseT_Half |
< 				SUPPORTED_100baseT_Full);
< 
< 	return 0;
< }
< 
< static void profibus_init(int evm_id, int profile)
---
> // setup spi0
> static void spi0_init(int evm_id, int profile)
2397c1008,1010
< 	setup_pin_mux(profibus_pin_mux);
---
> 	setup_pin_mux(spi0_pin_mux);
> 	spi_register_board_info(mc341_spi0_slave_info,
> 			ARRAY_SIZE(mc341_spi0_slave_info));
2400,2457c1013,1019
< 
< /* General Purpose EVM */
< static struct evm_dev_cfg gen_purp_evm_dev_cfg[] = {
< 	{enable_ecap0,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
< 						PROFILE_2 | PROFILE_7) },
< 	{lcdc_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
< 						PROFILE_2 | PROFILE_7) },
< 	{tsc_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_1 |
< 						PROFILE_2 | PROFILE_7) },
< 	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{rgmii2_init,	DEV_ON_DGHTR_BRD, (PROFILE_1 | PROFILE_2 |
< 						PROFILE_4 | PROFILE_6) },
< 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{evm_nand_init, DEV_ON_DGHTR_BRD,
< 		(PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3)},
< 	{i2c1_init,     DEV_ON_DGHTR_BRD, (PROFILE_ALL & ~PROFILE_2)},
< 	{lis331dlh_init, DEV_ON_DGHTR_BRD, (PROFILE_ALL & ~PROFILE_2)},
< 	{mcasp1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3 | PROFILE_7)},
< 	{mmc1_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
< 	{mmc2_wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 |
< 								PROFILE_5)},
< 	{mmc0_init,	DEV_ON_BASEBOARD, (PROFILE_ALL & ~PROFILE_5)},
< 	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_5},
< 	{spi0_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
< 	{uart1_wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 |
< 								PROFILE_5)},
< 	{wl12xx_init,	DEV_ON_BASEBOARD, (PROFILE_0 | PROFILE_3 | PROFILE_5)},
< 	{d_can_init,	DEV_ON_DGHTR_BRD, PROFILE_1},
< 	{matrix_keypad_init, DEV_ON_DGHTR_BRD, PROFILE_0},
< 	{volume_keys_init,  DEV_ON_DGHTR_BRD, PROFILE_0},
< 	{uart2_init,	DEV_ON_DGHTR_BRD, PROFILE_3},
< 	{haptics_init,	DEV_ON_DGHTR_BRD, (PROFILE_4)},
< 	{NULL, 0, 0},
< };
< 
< /* Industrial Auto Motor Control EVM */
< static struct evm_dev_cfg ind_auto_mtrl_evm_dev_cfg[] = {
< 	{mii1_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
< 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{profibus_init, DEV_ON_DGHTR_BRD, PROFILE_ALL},
< 	{evm_nand_init, DEV_ON_DGHTR_BRD, PROFILE_ALL},
< 	{spi1_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
< 	{uart3_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL},
< 	{i2c1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{NULL, 0, 0},
< };
< 
< /* Beaglebone < Rev A3 */
< static struct evm_dev_cfg beaglebone_old_dev_cfg[] = {
< 	{rmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{NULL, 0, 0},
---
> // update 2015.02.04 UART3, SPI1 init
> static struct pinmux_config spi1_pin_mux[] = {
> 	{"mcasp0_aclkx.spi1_sclk", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},	/* SPI1_SCLK ROM[CLK] */
> 	{"mcasp0_fsx.spi1_d0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},/* SPI1_D0 ROM[MISO] */
> 	{"mcasp0_axr0.spi1_d1", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},/* SPI1_D1 ROM[MOSI] */
> 	{"mcasp0_ahclkr.spi1_cs0", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT_PULLUP},	/* SPI1_CS0 ROM[CS] */
> 	{NULL, 0},
2459,2468c1021,1040
< 
< /* Beaglebone Rev A3 and after */
< static struct evm_dev_cfg beaglebone_dev_cfg[] = {
< 	{tps65217_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{mii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{i2c2_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
< 	{NULL, 0, 0},
---
> // update 2015.02.04 UART3, SPI1 init
> static struct pinmux_config uart3_pin_mux[] = {
> 	{"mii1_rxd3.uart3_rxd", OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},/* UART3_RXD 3G-CN */
> 	{"mii1_rxd2.uart3_txd", OMAP_MUX_MODE1 | AM33XX_PIN_OUTPUT},	/* UART3_TXD 3G-CN */
> // update 2015.02.05 uart3 update
> //	{"uart1_rtsn.uart1_rtsn", OMAP_MUX_MODE6 | AM33XX_PIN_INPUT_PULLUP},/* UART3_RTSn 3G-CN */
> //	{"uart1_ctsn.uart1_ctsn", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT},	/* UART3_CTSn 3G-CN */
> 	{"lcd_data11.uart3_rtsn", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT},/* UART3_RTSn 3G-CN */
> 	{"lcd_data10.uart3_ctsn", OMAP_MUX_MODE6 | AM33XX_PIN_INPUT_PULLUP},	/* UART3_CTSn 3G-CN */
> 	{NULL, 0},
> };
> // update 2015.02.26 uart5 update
> static struct pinmux_config uart5_pin_mux[] = {
> 	{"uart5_rxd", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLUP},/* UART5_RXD */
> 	{"uart5_txd", OMAP_MUX_MODE4 | AM33XX_PIN_OUTPUT},	/* UART5_TXDN */
> //	{"uart5_rtsn", OMAP_MUX_MODE6 | AM33XX_PIN_INPUT_PULLUP},/* UART5_RTSn */
> //	{"uart5_ctsn", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT},	/* UART5_CTSn */
> 	{"uart5_rtsn", OMAP_MUX_MODE6 | AM33XX_PIN_OUTPUT},/* UART5_RTSn */
> 	{"uart5_ctsn", OMAP_MUX_MODE6 | AM33XX_PIN_INPUT_PULLUP},	/* UART5_CTSn */
> 	{NULL, 0},
2471a1044
> // koko
2473c1046
< 	{mmc1_wl12xx_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
---
> //	{mmc1_wl12xx_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
2475,2486c1048,1071
< 	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{rgmii2_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{lcdc_init,     DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{enable_ecap2,     DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{tsc_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{gpio_keys_init,  DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{gpio_led_init,  DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{lis331dlh_init, DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{mcasp1_init,   DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{uart1_wl12xx_init, DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{wl12xx_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
< 	{gpio_ddr_vtt_enb_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
---
> //	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
> //	{rgmii2_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
> 	{rmii1_init,	DEV_ON_BASEBOARD, PROFILE_ALL}, // take
> 	{lcdc_init,     DEV_ON_BASEBOARD, PROFILE_ALL}, // 2014.12.12
> // 1129	{enable_ecap2,     DEV_ON_BASEBOARD, PROFILE_ALL},
> //	{tsc_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
> 	{gpio_keys_init,  DEV_ON_BASEBOARD, PROFILE_ALL}, // add 2014.12.01
> 	{gpio_led_init,  DEV_ON_BASEBOARD, PROFILE_ALL}, // add 2014.12.01
> // 1129	{lis331dlh_init, DEV_ON_BASEBOARD, PROFILE_ALL},
> // 1129	{mcasp1_init,   DEV_ON_BASEBOARD, PROFILE_ALL},
> #ifdef CONFIG_MACH_MC341_CHANGE_UART1_TO_DCAN // add 2015.07.02 .. see Kconfig
> 	{dcan_init, DEV_ON_BASEBOARD, PROFILE_ALL},
> #else
> 	{uart1_wl12xx_init, DEV_ON_BASEBOARD, PROFILE_ALL}, // add 2014.12.01
> #endif
> //	{wl12xx_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
> // 1129	{gpio_ddr_vtt_enb_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
> // 1206	{spi0_init,	DEV_ON_DGHTR_BRD, PROFILE_2}, // add 2014.11.24
> // 	{spi0_init,	DEV_ON_DGHTR_BRD, PROFILE_ALL}, // add 2014.11.24
> //	{spi0_init,	DEV_ON_DGHTR_BRD, PROFILE_0}, // for spidev add 1207
>  	{spi0_init,	DEV_ON_BASEBOARD, PROFILE_ALL}, // add 2014.12.23
> 	{usb0_init,	DEV_ON_BASEBOARD, PROFILE_ALL},// add 2015.02.27
> 	{usb1_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
> 
2490c1075,1077
< static int am33xx_evm_tx_clk_dly_phy_fixup(struct phy_device *phydev)
---
> // add 2014.11.25
> #ifdef CONFIG_TLK110_WORKAROUND
> static int mc341_tlk110_phy_fixup(struct phy_device *phydev)
2492,2494c1079
< 	phy_write(phydev, AR8051_PHY_DEBUG_ADDR_REG,
< 		  AR8051_DEBUG_RGMII_CLK_DLY_REG);
< 	phy_write(phydev, AR8051_PHY_DEBUG_DATA_REG, AR8051_RGMII_TX_CLK_DLY);
---
>  unsigned int val;
2496,2502c1081
< 	return 0;
< }
< 
< static void setup_general_purpose_evm(void)
< {
< 	u32 prof_sel = am335x_get_profile_selection();
< 	pr_info("The board is general purpose EVM in profile %d\n", prof_sel);
---
> // printk(KERN_WARNING "[%s](%d)mc341_tlk110_phy_fixup in!!!",__FILE__,__LINE__);
2504c1083,1086
< 	_configure_device(GEN_PURP_EVM, gen_purp_evm_dev_cfg, (1L << prof_sel));
---
>  /* This is done as a workaround to support TLK110 rev1.0 phy */
>  // TLK110_COARSEGAIN_REG 0x00A3
>  val = phy_read(phydev, TLK110_COARSEGAIN_REG);
>  phy_write(phydev, TLK110_COARSEGAIN_REG, (val | TLK110_COARSEGAIN_VAL));
2506,2510c1088,1090
< 	am33xx_cpsw_init(AM33XX_CPSW_MODE_RGMII, NULL, NULL);
< 	/* Atheros Tx Clk delay Phy fixup */
< 	phy_register_fixup_for_uid(AM335X_EVM_PHY_ID, AM335X_EVM_PHY_MASK,
< 				   am33xx_evm_tx_clk_dly_phy_fixup);
< }
---
>  // TLK110_LPFHPF_REG 0x00AC
>  val = phy_read(phydev, TLK110_LPFHPF_REG);
>  phy_write(phydev, TLK110_LPFHPF_REG, (val | TLK110_LPFHPF_VAL));
2512,2514c1092,1094
< static void setup_ind_auto_motor_ctrl_evm(void)
< {
< 	u32 prof_sel = am335x_get_profile_selection();
---
>  // TLK110_SPAREANALOG_REG 0x00B9
>  val = phy_read(phydev, TLK110_SPAREANALOG_REG);
>  phy_write(phydev, TLK110_SPAREANALOG_REG, (val | TLK110_SPANALOG_VAL));
2516,2517c1096,1098
< 	pr_info("The board is an industrial automation EVM in profile %d\n",
< 		prof_sel);
---
>  // TLK110_VRCR_REG 0x00D0
>  val = phy_read(phydev, TLK110_VRCR_REG);
>  phy_write(phydev, TLK110_VRCR_REG, (val | TLK110_VRCR_VAL));
2519,2524c1100,1102
< 	/* Only Profile 0 is supported */
< 	if ((1L << prof_sel) != PROFILE_0) {
< 		pr_err("AM335X: Only Profile 0 is supported\n");
< 		pr_err("Assuming profile 0 & continuing\n");
< 		prof_sel = PROFILE_0;
< 	}
---
>  // TLK110_SETFFE_REG 0x0107
>  val = phy_read(phydev, TLK110_SETFFE_REG);
>  phy_write(phydev, TLK110_SETFFE_REG, (val | TLK110_SETFFE_VAL));
2526,2527c1104,1106
< 	_configure_device(IND_AUT_MTR_EVM, ind_auto_mtrl_evm_dev_cfg,
< 		PROFILE_0);
---
>  // TLK110_FTSP_REG 0x0154
>  val = phy_read(phydev, TLK110_FTSP_REG);
>  phy_write(phydev, TLK110_FTSP_REG, (val | TLK110_FTSP_VAL));
2529,2530c1108,1110
< 	am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, "0:1e", "0:00");
< }
---
>  // TLK110_ALFATPIDL_REG 0x002A
>  val = phy_read(phydev, TLK110_ALFATPIDL_REG);
>  phy_write(phydev, TLK110_ALFATPIDL_REG, (val | TLK110_ALFATPIDL_VAL));
2532,2535c1112,1114
< /* BeagleBone < Rev A3 */
< static void setup_beaglebone_old(void)
< {
< 	pr_info("The board is a AM335x Beaglebone < Rev A3.\n");
---
>  // TLK110_PSCOEF21_REG 0x0096
>  val = phy_read(phydev, TLK110_PSCOEF21_REG);
>  phy_write(phydev, TLK110_PSCOEF21_REG, (val | TLK110_PSCOEF21_VAL));
2537,2538c1116,1118
< 	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
< 	am335x_mmc[0].gpio_wp = -EINVAL;
---
>  // TLK110_PSCOEF3_REG 0x0097
>  val = phy_read(phydev, TLK110_PSCOEF3_REG);
>  phy_write(phydev, TLK110_PSCOEF3_REG, (val | TLK110_PSCOEF3_VAL));
2540,2541c1120,1122
< 	_configure_device(BEAGLE_BONE_OLD, beaglebone_old_dev_cfg,
< 								PROFILE_NONE);
---
>  // TLK110_ALFAFACTOR1_REG 0x002C
>  val = phy_read(phydev, TLK110_ALFAFACTOR1_REG);
>  phy_write(phydev, TLK110_ALFAFACTOR1_REG, (val | TLK110_ALFACTOR1_VAL));
2543,2544c1124,1126
< 	phy_register_fixup_for_uid(BBB_PHY_ID, BBB_PHY_MASK,
< 					beaglebone_phy_fixup);
---
>  // TLK110_ALFAFACTOR2_REG 0x0023
>  val = phy_read(phydev, TLK110_ALFAFACTOR2_REG);
>  phy_write(phydev, TLK110_ALFAFACTOR2_REG, (val | TLK110_ALFACTOR2_VAL));
2546,2547c1128,1130
< 	am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII, NULL, NULL);
< }
---
>  // TLK110_CFGPS_REG 0x0095
>  val = phy_read(phydev, TLK110_CFGPS_REG);
>  phy_write(phydev, TLK110_CFGPS_REG, (val | TLK110_CFGPS_VAL));
2549,2552c1132,1134
< /* BeagleBone after Rev A3 */
< static void setup_beaglebone(void)
< {
< 	pr_info("The board is a AM335x Beaglebone.\n");
---
>  // TLK110_FTSPTXGAIN_REG 0x0150
>  val = phy_read(phydev, TLK110_FTSPTXGAIN_REG);
>  phy_write(phydev, TLK110_FTSPTXGAIN_REG, (val | TLK110_FTSPTXGAIN_VAL));
2554,2555c1136,1138
< 	/* Beagle Bone has Micro-SD slot which doesn't have Write Protect pin */
< 	am335x_mmc[0].gpio_wp = -EINVAL;
---
>  // TLK110_SWSCR3_REG 0x000B
>  val = phy_read(phydev, TLK110_SWSCR3_REG);
>  phy_write(phydev, TLK110_SWSCR3_REG, (val | TLK110_SWSCR3_VAL));
2557c1140,1142
< 	_configure_device(BEAGLE_BONE_A3, beaglebone_dev_cfg, PROFILE_NONE);
---
>  // TLK110_SCFALLBACK_REG 0x0040
>  val = phy_read(phydev, TLK110_SCFALLBACK_REG);
>  phy_write(phydev, TLK110_SCFALLBACK_REG, (val | TLK110_SCFALLBACK_VAL));
2559,2560c1144,1146
< 	/* TPS65217 regulator has full constraints */
< 	regulator_has_full_constraints();
---
>  // TLK110_PHYRCR_REG 0x001F
>  val = phy_read(phydev, TLK110_PHYRCR_REG);
>  phy_write(phydev, TLK110_PHYRCR_REG, (val | TLK110_PHYRCR_VAL));
2562c1148
< 	am33xx_cpsw_init(AM33XX_CPSW_MODE_MII, NULL, NULL);
---
>  return 0;
2563a1150,1151
> #endif
> 
2567a1156,1158
> // koko
> // printk(KERN_WARNING "[%s](%d)setup force!!!", __FILE__,__LINE__ );
> 
2571c1162
< 	am335x_mmc[0].gpio_wp = -EINVAL;
---
> 	mc341_mmc[0].gpio_wp = -EINVAL;
2572a1164
> // printk(KERN_WARNING "[%s](%d)_configure_device in!!!", __FILE__,__LINE__ );
2575,2579c1167,1172
< 	am33xx_cpsw_init(AM33XX_CPSW_MODE_RGMII, NULL, NULL);
< 	/* Atheros Tx Clk delay Phy fixup */
< 	phy_register_fixup_for_uid(AM335X_EVM_PHY_ID, AM335X_EVM_PHY_MASK,
< 				   am33xx_evm_tx_clk_dly_phy_fixup);
< }
---
> 	// update 2015.02.18 am33xx_cpsw_init
> 	// am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII, "0:00", "0:1e");
> 	am33xx_cpsw_init(AM33XX_CPSW_MODE_RMII, "0:00", "0:01");
> 
> 	/* Initialize TLK110 PHY registers for phy version 1.0 */
> 	mc341_tlk110_phy_init();
2581c1174,1200
< static void am335x_setup_daughter_board(struct memory_accessor *m, void *c)
---
> 	// update 2015.02.04 UART3, SPI1 init
> 	setup_pin_mux(uart3_pin_mux);
> 	// update 2015.02.26 uart5 update
> 	setup_pin_mux(uart5_pin_mux);
> 	setup_pin_mux(spi1_pin_mux);
> 	
> 	// update 2015.02.06 2LAN setup
> 	if( MC341LAN2 ){
> 		int ret;
> 		setup_pin_mux(rmii2_pin_mux);
> 		setup_pin_mux(mc341_lan2_model);
>         	// 2015.02.09
>         	#define GPIO_INIT_END GPIO_TO_PIN(0, 16)
>         	ret = gpio_request(GPIO_INIT_END, "GPIO_INIT_END");
>         	if (!ret) {
>         		gpio_direction_output(GPIO_INIT_END, 1);
> 		}else{
>            	     printk(KERN_ERR "%s: failed to request GPIO for GPIO_INIT_END port "
>                        "gpio control: %d\n", __func__, ret);
>         	}
> 	}else{ // LAN 1 model
> 		setup_pin_mux(mc341_lan1_model);
> 	}
> 
> }
> /*
> static void mc341_setup_daughter_board(struct memory_accessor *m, void *c)
2583c1202
< 	int ret;
---
> //	int ret;
2585,2588c1204,1207
< 	/*
< 	 * Read from the EEPROM to see the presence of daughter board.
< 	 * If present, print the cpld version.
< 	 */
---
> 	//
> 	// Read from the EEPROM to see the presence of daughter board.
> 	// If present, print the cpld version.
> 	//
2613a1233
> 
2614a1235
> */
2616c1237
< static void bone_setup_daughter_board(struct memory_accessor *m, void *c)
---
> static void mc341_setup(struct memory_accessor *mem_acc, void *context)
2618a1240
> 	char tmp[10];
2620,2631c1242,1243
< 	/*
< 	 * Read from the EEPROM to see the presence
< 	 * of daughter board. If present, get daughter board
< 	 * specific data.
< 	 */
< 	pr_info("IN : %s \n", __FUNCTION__);
< 	ret = m->read(m, (char *) &cape_eeprom_config, 0,
< 			sizeof( struct lcd_cape_eeprom_config));
< 
< 	if (ret == sizeof (struct lcd_cape_eeprom_config))
< 	{
< 		pr_info("Detected a daughter card on BeagleBone..");
---
> // koko
> printk(KERN_INFO "mc341_setup in!!!" );
2633c1245,1253
< 		if ( strcmp (cape_eeprom_config.board_name, "BeagleBone LCD Cape") == 0)
---
> 	ret = mem_acc->read(mem_acc, (char *)&config_mc341,
> 		0, sizeof(config_mc341));
> 	if( ret == sizeof(config_mc341)){
> printk(KERN_INFO "config_mc341 data " );
> printk(KERN_INFO "config_mc341.header=[%x]", config_mc341.header );
> printk(KERN_INFO "config_mc341.name=[%.8s]", config_mc341.name );
> printk(KERN_INFO "config_mc341.clock_mem=[%x]", config_mc341.clock_mem );
> printk(KERN_INFO "config_mc341.display=[%x]", config_mc341.display );
> 		// mac addr
2635,2646c1255,1265
< 			pr_info("BeagleBone LCD cape board detected\n");
< 			printk ("Board Name: %s\n", cape_eeprom_config.board_name);
< 			printk ("manufacurer : %s", cape_eeprom_config.manufacturer);
< 			bone_lcdc_init (DEV_ON_DGHTR_BRD, PROFILE_NONE);
< 			lcd_cape_keys_init(DEV_ON_DGHTR_BRD, PROFILE_NONE);
< 			lcd_cape_tsc_init ( DEV_ON_DGHTR_BRD, PROFILE_NONE);
< 			return;
< 		}
< 		else{
< 			/* Setup DVI display if daughter card detected is not LCD cape. */
< 			dvi_init( DEV_ON_DGHTR_BRD, PROFILE_NONE);
< 			return;
---
> 			char buf[128],wk[16];
> 			int i,j;
> 			memcpy( (char *)&am335x_mac_addr[0][0], (char *)&config_mc341.mac0, 12);
> 			for(i=0;i<2;i++){
> 				memset( buf, 0, sizeof(buf) );
> 				for(j=0;j<6;j++){
> 					sprintf( wk, "[%2.2x]", am335x_mac_addr[i][j] );
> 					strcat( buf, wk );
> 				}
> 				printk(KERN_INFO "eth%d mac{%s}", i, buf ); // 0102
> 			}
2648,2661c1267,1269
< 	}
< 
< 	/* Display needs to be initialized even if display daughter card is not found so as
< 	 * to enable framebuffer driver which is needed for successful Android bootup
< 	 */
< 	pr_info("No daughter card found on BeagleBone\n");
< 	vnc_lcdc_init (DEV_ON_BASEBOARD, PROFILE_NONE);
< 	return;
< }
< 
< static void am335x_evm_setup(struct memory_accessor *mem_acc, void *context)
< {
< 	int ret;
< 	char tmp[10];
---
> printk(KERN_INFO "config_mc341.ssp=[%x]", config_mc341.ssp );
> printk(KERN_INFO "config_mc341.debport=[%x]", config_mc341.debport );
> printk(KERN_INFO "config_mc341.serial=[%.14s]", config_mc341.serial );
2662a1271,1273
> 	}
> 	
> 	
2663a1275
> /*	
2666a1279,1280
> printk(KERN_WARNING "[%s](%d) EEPROM_MAC_ADDRESS_OFFSET=%d!!!", __FILE__,__LINE__, EEPROM_MAC_ADDRESS_OFFSET ); // 1223
> printk(KERN_WARNING "[%s](%d)ret=%d sizeof(am335x_mac_addr)=%d!!!", __FILE__,__LINE__, ret, sizeof(am335x_mac_addr) ); // 1223
2671c1285,1286
< 
---
> */
> 	
2676a1292
> /*
2677a1294
> printk(KERN_WARNING "[%s](%d)ret=%d sizeof(config)=%d!!!", __FILE__,__LINE__, ret, sizeof(config) ); // 0102
2683,2695c1300,1312
< // koko 
< int i;
< char wk[16];
< char buf[256];
< char *c;
< 
< c=(char *)&config;
< memset( buf, 0, sizeof(buf) );
< for( i=0; i<sizeof(config); i++){
<  sprintf( wk, "[%2.2x]", c[i] );
<  strcat( buf, wk );
< }
< printk(KERN_WARNING "[%s](%d)config read data{%s}", __FILE__,__LINE__, buf );
---
> 		// koko 
> 		int i;
> 		char wk[16];
> 		char buf[256];
> 		char *c;
> 
> 		c=(char *)&config;
> 		memset( buf, 0, sizeof(buf) );
> 		for( i=0; i<sizeof(config); i++){
> 		 sprintf( wk, "[%2.2x]", c[i] );
> 		 strcat( buf, wk );
> 		}
> 		printk(KERN_WARNING "[%s](%d)config read data{%s}", __FILE__,__LINE__, buf );
2697c1314,1315
< {
---
> */
> if(0){
2705a1324
> 	/*
2710a1330
> 	*/
2711a1332
> 	/*
2717c1338,1339
< 
---
> 	*/
> /*
2722,2730c1344,1346
< 
< 	if (!strncmp("A335BONE", config.name, 8)) {
< 		daughter_brd_detected = false;
< 		if(!strncmp("00A1", config.version, 4) ||
< 		   !strncmp("00A2", config.version, 4))
< 			setup_beaglebone_old();
< 		else
< 			setup_beaglebone();
< 	} else if (!strncmp("A335X_SK", config.name, 8)) {
---
> */
> 	
> //	if (!strncmp("A335X_SK", config.name, 8)) {
2731a1348
> // printk(KERN_WARNING "[%s](%d)setup_starterkit in!!!", __FILE__,__LINE__ );
2733,2744c1350,1351
< 	} else {
< 		/* only 6 characters of options string used for now */
< 		snprintf(tmp, 7, "%s", config.opt);
< 		pr_info("SKU: %s\n", tmp);
< 
< 		if (!strncmp("SKU#01", config.opt, 6))
< 			setup_general_purpose_evm();
< 		else if (!strncmp("SKU#02", config.opt, 6))
< 			setup_ind_auto_motor_ctrl_evm();
< 		else
< 			goto out;
< 	}
---
> //	} else {
> //	}
2762,2763c1369,1370
< 
< static struct at24_platform_data am335x_daughter_board_eeprom_info = {
---
> /*
> static struct at24_platform_data mc341_daughter_board_eeprom_info = {
2767c1374
< 	.setup          = am335x_setup_daughter_board,
---
> 	.setup          = mc341_setup_daughter_board,
2770,2775c1377,1384
< 
< static struct at24_platform_data am335x_baseboard_eeprom_info = {
< 	.byte_len       = (256*1024) / 8,
< 	.page_size      = 64,
< 	.flags          = AT24_FLAG_ADDR16,
< 	.setup          = am335x_evm_setup,
---
> */
> // I2C BUS 2Kbit(256x8bit) EEPROM - BR24L02F-W 
> static struct at24_platform_data mc341_baseboard_eeprom_info = {
> 	.byte_len       = (256*8) / 8,
> 	.page_size      = 8,
> 	// .flags          = AT24_FLAG_ADDR16, // 2015.01.16
> 	.flags          = 0,
> 	.setup          = mc341_setup,
2779,2787c1388,1389
< static struct at24_platform_data bone_daughter_board_eeprom_info = {
<         .byte_len       = (256*1024) / 8,
<         .page_size      = 64,
<         .flags          = AT24_FLAG_ADDR16,
<         .setup          = bone_setup_daughter_board,
<         .context        = (void *)NULL,
< };
< 
< 
---
> /*
> */
2791a1394,1395
> /*
> */
2795d1398
< 
2807c1410,1411
< 
---
> /*
> */
2811d1414
< 
2823c1426,1427
< 
---
> /*
> */
2849c1453,1455
< static struct i2c_board_info __initdata am335x_i2c0_boardinfo[] = {
---
> // 0x2d PMIC, 0x50 EEPROM, 0x6f RTC
> static struct i2c_board_info __initdata mc341_i2c0_boardinfo[] = {
> /*** 2014.12.23
2851,2852c1457,1458
< 		/* Daughter Board EEPROM */
< 		I2C_BOARD_INFO("24c256", DAUG_BOARD_I2C_ADDR),
---
> 		// Daughter Board EEPROM 
> 		I2C_BOARD_INFO("24c256", DAUG_BOARD_I2C_ADDR), // 0x51
2854a1461
> ***/
2857,2858c1464,1465
< 		I2C_BOARD_INFO("24c256", BASEBOARD_I2C_ADDR),
< 		.platform_data  = &am335x_baseboard_eeprom_info,
---
> 		I2C_BOARD_INFO("24c256", BASEBOARD_I2C_ADDR), // 0x50
> 		.platform_data  = &mc341_baseboard_eeprom_info,
2859a1467
> /*** 2014.12.23
2867c1475,1481
< 		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
---
> 		I2C_BOARD_INFO("tlv320aic3x", 0x1b),
> 	},
> ***/
> // 2015.2.11 add 
> /****
> 	{
> 		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1), // 0x2d
2869a1484,1485
> ****/
> // update 2015.03.05 RTC mcp7940
2871c1487,1493
< 		I2C_BOARD_INFO("tlv320aic3x", 0x1b),
---
> //		I2C_BOARD_INFO("rtc-mcp7940", 0x6f), // RTC
> 		I2C_BOARD_INFO("mcp7940", 0x6f), // RTC
> 	},
> // update 2015.04.28 RTC rtc-rx8900
> 	{
> //		I2C_BOARD_INFO("rtc-rx8900", 0x32), // RTC
> 		I2C_BOARD_INFO("rx8900", 0x32), // RTC
2872a1495
> 
2874a1498,1515
> // update 2015.03.16 RFID add
> // 0x54 RFID
> static struct i2c_board_info __initdata mc341_i2c1_boardinfo[] = {
> 	{
> 		I2C_BOARD_INFO("rfid", 0x54), // RFID
> 	},
> };
> // update 2015.03.16 RFID add
> static struct pinmux_config i2c1_pin_mux[] = {
> //	{"uart0_ctsn.i2c1_sda", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
> ////	{"uart0_ctsn.i2c1_sda", OMAP_MUX_MODE3 | AM33XX_PIN_INPUT},
> //	{"uart0_rtsn.i2c1_scl", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT|AM33XX_PIN_INPUT_PULLUP},
> ////	{"uart0_rtsn.i2c1_scl", OMAP_MUX_MODE3 | AM33XX_PIN_OUTPUT},
> 	{"gpmc_ad8.gpio0_22", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLDOWN},
> //	{"gpmc_ad9.gpio0_23", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT |AM33XX_INPUT_EN},
> 	{"gpmc_ad9.gpio0_23", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT },
> 	{NULL, 0},
> };
2882c1523,1524
< 	.mode           = (MUSB_HOST << 4) | MUSB_OTG,
---
> 	// .mode           = (MUSB_HOST << 4) | MUSB_OTG,
> 	.mode           = (MUSB_HOST << 4) | MUSB_HOST,
2919c1561
< static void __init am335x_evm_i2c_init(void)
---
> static void __init mc341_i2c_init(void)
2920a1563,1564
> 	int ret=0;
> 	
2922c1566
< 	am335x_evm_id = GEN_PURP_EVM;
---
> 	// am335x_evm_id = GEN_PURP_EVM;
2926,2927c1570,1600
< 	omap_register_i2c_bus(1, 100, am335x_i2c0_boardinfo,
< 				ARRAY_SIZE(am335x_i2c0_boardinfo));
---
> 	omap_register_i2c_bus(1, 100, mc341_i2c0_boardinfo,
> 				ARRAY_SIZE(mc341_i2c0_boardinfo));
> 
> // update 2015.03.16 RFID add
> 	setup_pin_mux(i2c1_pin_mux);
> if(0){
>          #define GPIO_INIT_I2C1 GPIO_TO_PIN(0, 23)
>          ret = gpio_request(GPIO_INIT_I2C1, "GPIO_INIT_I2C1");
>          if (!ret) {
>             gpio_direction_output(GPIO_INIT_I2C1, 1);
>             // gpio_direction_output(GPIO_INIT_I2C1, 0);
>          }else{
>             printk(KERN_ERR "%s: failed to request GPIO for GPIO_INIT_I2C1 port "
>                        "gpio control: %d\n", __func__, ret);
>          }
> }
> if(1){
> 	omap_register_i2c_bus(2, 100, mc341_i2c1_boardinfo,
> 				ARRAY_SIZE(mc341_i2c1_boardinfo));
> }
> 
> 	// 2014.12.23
> 	#define SPI0_ROM_WPN GPIO_TO_PIN(3, 10)
> 	
> 	ret = gpio_request(SPI0_ROM_WPN, "SPI0_ROM_WPN");
> 	if (ret) {
> 		printk(KERN_ERR "%s: failed to request GPIO for SPI0_ROM_WPN port "
> 		       "power control: %d\n", __func__, ret);
> 		return;
> 	}
> 	gpio_direction_output(SPI0_ROM_WPN, 1);
2930c1603
< static struct resource am335x_rtc_resources[] = {
---
> static struct resource mc341_rtc_resources[] = {
2948c1621
< static struct platform_device am335x_rtc_device = {
---
> static struct platform_device mc341_rtc_device = {
2951,2952c1624,1625
< 	.num_resources	= ARRAY_SIZE(am335x_rtc_resources),
< 	.resource	= am335x_rtc_resources,
---
> 	.num_resources	= ARRAY_SIZE(mc341_rtc_resources),
> 	.resource	= mc341_rtc_resources,
2955c1628
< static int am335x_rtc_init(void)
---
> static int mc341_rtc_init(void)
2986c1659,1660
< 	writel(0x48, base + 0x54);
---
> 	// writel(0x48, base + 0x54);
> 	writel(0x40, base + 0x54); // upd 2015.01.06
2990c1664
< 	return  platform_device_register(&am335x_rtc_device);
---
> 	return  platform_device_register(&mc341_rtc_device);
3076c1750,1752
< static void __init am335x_evm_init(void)
---
> static void make_spread_spectrum(void);
> 
> static void __init mc341_init(void)
3077a1754
> // printk(KERN_WARNING "[%s](%d)am33xx_cpuidle_init in!!!",__FILE__,__LINE__); // 12.23
3078a1756
> // printk(KERN_WARNING "[%s](%d)am33xx_mux_init in!!!",__FILE__,__LINE__); // 12.23
3079a1758
> // printk(KERN_WARNING "[%s](%d)omap_serial_init in!!!",__FILE__,__LINE__); // 12.23
3081c1760,1763
< 	am335x_rtc_init();
---
> // printk(KERN_WARNING "[%s](%d)mc341_rtc_init in!!!",__FILE__,__LINE__); // 12.23
> // 2015.03.06 RTC update
> //	mc341_rtc_init();
> // printk(KERN_WARNING "[%s](%d)clkout2_enable in!!!",__FILE__,__LINE__); // 12.23
3083c1765,1767
< 	am335x_evm_i2c_init();
---
> // printk(KERN_WARNING "[%s](%d)mc341_i2c_init in!!!",__FILE__,__LINE__); // 12.23
> 	mc341_i2c_init();
> // printk(KERN_WARNING "[%s](%d)omap_sdrc_init in!!!",__FILE__,__LINE__); // 12.23
3085c1769,1770
< 	usb_musb_init(&musb_board_data);
---
> // printk(KERN_WARNING "[%s](%d)usb_musb_init in!!!",__FILE__,__LINE__); // 12.23
> 
3093a1779,1803
> 	// 2015.2.11 add usb
> 	usb_musb_init(&musb_board_data);
> 
> // update 2015.03.05 CM_CLOCKOUT_CTRL
> {
>     void __iomem* io_base;
>     unsigned int m;
>     io_base = ioremap(AM33XX_CM_BASE + AM33XX_CM_DEVICE_MOD, 0x4);
>     if (!io_base) {
>         printk(KERN_ERR "ioremap CM_CLKOUT_CTRL failed\n");
>         return;
>     }
>     m=readl(io_base+0x0);
>     printk(KERN_INFO "CM_CLKOUT_CTRL[%x]\n", m );
>     m &= ~0x3f;
>     m |= ( 0x4 <<3 ); // 0x4=DIV5:SYS_CLKOUT2/5
>     m |= ( 0x1 ); // 0x1=SEL1:Select L3 Clock
>     writel(m, io_base+0x0);
>     printk(KERN_INFO "CM_CLKOUT_CTRL[%x]\n", m );
>     iounmap(io_base);
> }
> 
> 
> 	make_spread_spectrum();
> 
3096c1806
< static void __init am335x_evm_map_io(void)
---
> static void __init mc341_map_io(void)
3101a1812,1821
> MACHINE_START(MC341, "mc341")
> 	// Maintainer: Texas Instruments
> 	.atag_offset	= 0x100,
> 	.map_io		= mc341_map_io,
> 	.init_early	= am33xx_init_early,
> 	.init_irq	= ti81xx_init_irq,
> 	.handle_irq     = omap3_intc_handle_irq,
> 	.timer		= &omap3_am33xx_timer,
> 	.init_machine	= mc341_init,
> MACHINE_END
3103c1823
< 	/* Maintainer: Texas Instruments */
---
> 	// Maintainer: Texas Instruments
3105c1825
< 	.map_io		= am335x_evm_map_io,
---
> 	.map_io		= mc341_map_io,
3110c1830
< 	.init_machine	= am335x_evm_init,
---
> 	.init_machine	= mc341_init,
3112c1832
< 
---
> /*
3114c1834
< 	/* Maintainer: Texas Instruments */
---
> 	// Maintainer: Texas Instruments
3116c1836
< 	.map_io		= am335x_evm_map_io,
---
> 	.map_io		= mc341_map_io,
3120c1840
< 	.init_machine	= am335x_evm_init,
---
> 	.init_machine	= mc341_init,
3121a1842,1989
> */
> /********************************* Spread Spectrum Clocking ****************************/
> 
> 
> 
> /* Descriptor for Spread Spectrum Clocking */
> struct ssc_data {
>     const  char* name;          /* Name of the clock */
>     unsigned int percent;       /* SSC modulation strength in % */
>     unsigned int clksel;        /* Offset to CLKSEL register */
>     unsigned int deltamstep;    /* Offset to DELTAMSTEP register */
>     unsigned int modfreqdiv;    /* Offset to DELTAMSTEP register */
>     unsigned int clkmode;       /* Offset to CLKMODE register */
> };
> 
> /* Descriptor for all AM335x clocks */
> static const struct ssc_data mpu_dpll_data = {
>         .name       = "MPU",
>         .percent    = 2,
>         .clksel     = 0x2C,
>         .deltamstep = 0x24,
>         .modfreqdiv = 0x28,
>         .clkmode    = 0x88,
> };
> 
> static const struct ssc_data ddr_dpll_data = {
>         .name       = "DDR",
>         .percent    = 2,
>         .clksel     = 0x40,
>         .deltamstep = 0x38,
>         .modfreqdiv = 0x3C,
>         .clkmode    = 0x94,
> };
> 
> static const struct ssc_data lcd_dpll_data = {
>         .name       = "LCD",
>         .percent    = 2,
>         .clksel     = 0x54,
>         .deltamstep = 0x4C,
>         .modfreqdiv = 0x50,
>         .clkmode    = 0x98,
> };
> 
> static const struct ssc_data core_dpll_data = {
>         .name       = "COR",
>         .percent    = 2,
>         .clksel     = 0x68,
>         .deltamstep = 0x60,
>         .modfreqdiv = 0x64,
>         .clkmode    = 0x90,
> };
> 
> static const struct ssc_data per_dpll_data = {
>         .name       = "PER",
>         .percent    = 2,    // watch for V24 jitter!
>         .clksel     = 0x9C,
>         .deltamstep = 0x74,
>         .modfreqdiv = 0x78,
>         .clkmode    = 0x8C,
> };
> 
> /* Function for setup SSC */
> static void spread_spectrum_setup(const struct ssc_data* dpll_data)
> {
>     void __iomem* clock_base;
>     struct clk* clock;
>     unsigned int f;
>     unsigned int fm;
>     unsigned int m;
>     unsigned int n;
>     unsigned int ModFreqDivider;
>     unsigned int Exponent;
>     unsigned int Mantissa;
>     unsigned int delta_m_step;
> 
>     clock_base = ioremap(AM33XX_CM_BASE + AM33XX_CM_WKUP_MOD, 0x1000);
>     if (!clock_base) {
>         printk(KERN_ERR "ioremap spread spectrum clocks failed\n");
>         return;
>     }
> 
>     /* Read PLL dividers m and n */
>     m = readl(clock_base + dpll_data->clksel);
>     n = m & 0x7F;
>     m = (m >> 8) & 0x3FF;
>     // printk(KERN_ERR "%s PLL m = %d, n = %d\n", dpll_data->name, m, n);
> 
>     /* Calculate Fref */
>     clock = clk_get(NULL, "sys_clkin_ck");
>     f = clk_get_rate(clock);
>     f = f/(1+n);
>     // printk(KERN_ERR "%s PLL reference clock is %dHz\n", dpll_data->name, f);
> 
>     /* Calculate max. Bandwidth (Modulation Frequency) of PLL */
>     fm = f / 70;
>     // printk(KERN_ERR "%s PLL Bandwidth is %d\n", dpll_data->name, fm);
> 
>     /* Calculate ModFreqDivider */
>     ModFreqDivider = f/(4 * fm);
>     // printk(KERN_ERR "%s PLL ModFreqDivider is %d\n", dpll_data->name, ModFreqDivider);
> 
>     /* Calculate Mantissa/Exponent */
>     Exponent = 0;
>     Mantissa = ModFreqDivider;
>     while ((Mantissa > 127) && (Exponent < 7)) {
>         Exponent++;
>         Mantissa /= 2;
>     }
>     if (Mantissa > 127)
>         Mantissa = 127;
>     // printk(KERN_ERR "%s PLL Mantissa = %d, Exponent = %d\n", dpll_data->name, Mantissa, Exponent);
>     ModFreqDivider = Mantissa << Exponent;
>     // printk(KERN_ERR "%s PLL revised ModFreqDivider is %d\n", dpll_data->name, ModFreqDivider);
> 
>     /* Calculate Modulation steps */
>     delta_m_step = (m * dpll_data->percent) << 18;
>     delta_m_step /= 100;
>     delta_m_step /= ModFreqDivider;
>     if (delta_m_step > 0xFFFFF)
>         delta_m_step = 0xFFFFF;
>     // printk(KERN_ERR "%s PLL Delta_M_Int = %d, Delta_M_Frac = %d\n", dpll_data->name, delta_m_step >> 18, delta_m_step & 0x3FFFF);
> 
>     /* Setup Spread Spectrum */
>     writel(delta_m_step, clock_base + dpll_data->deltamstep);
>     writel((Exponent << 8) | Mantissa, clock_base + dpll_data->modfreqdiv);
>     m = readl(clock_base + dpll_data->clkmode);
>     m &= ~0xF000;   // clear all SSC flags
>     m |=  0x1000;   // enable SSC
>     writel(m, clock_base + dpll_data->clkmode);
>     printk(KERN_INFO "%s PLL Spread Spectrum enabled with %d percent\n", dpll_data->name, dpll_data->percent);
> 
>     iounmap(clock_base); // 2014.12.12
> }
> 
> 
> static void make_spread_spectrum(void)
> {
> 	if(0){
> 		printk(KERN_WARNING "[%s](%d)make_spread_spectrum[CPU,MEM] in!!!",__FILE__,__LINE__);
> 		spread_spectrum_setup(&mpu_dpll_data); // CPU
> 		spread_spectrum_setup(&ddr_dpll_data); // MEM
> 	}
> //    spread_spectrum_setup(&lcd_dpll_data);
> //    spread_spectrum_setup(&core_dpll_data);
> //    spread_spectrum_setup(&per_dpll_data);
> }
> 
> 
